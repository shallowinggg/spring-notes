一个企业应用一般不会只包含一个对象（或者在Spring中只包含一个bean定义）。即使是最简单的应用也有几个对象协同工作来让用户看起来它是一个连贯的应用。下一节解释了如何为一个完全真实的应用定义一系列相互独立的bean，这些bean可以相互组合完成想要的目标。

### 1.4.1. Dependency Injection

依赖注入(DI)是一个过程，在这个过程下对象只通过构造方法的参数或工厂方法的参数来设置自己属性，或者在通过构造方法或工厂方法创建后调用setter方法来设置自身的属性，而这些属性就是依赖。Spring容器会在创建bean的时候注入它所需的依赖，这个过程反转了bean自己控制的实例化以及设置依赖的过程，正如它的名字一样，控制反转（ Inversion of Control）。

使用DI原则的代码更加简洁清晰，并且当对象在被提供它们的依赖时能够更有效地解耦。此时，对象不需要去查找它们的依赖，也不需要知道依赖所在的位置。因此，你的类能够更加容易进行测试，特别是当依赖是一个接口或者抽象类时，为它的子类实现在单元测试中使用留出余地。

DI主要有两个变种： [Constructor-based dependency injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection) 以及 [Setter-based dependency injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection)。

#### Constructor-based Dependency Injection

基于构造方法的依赖注入通过容器调用构造方法来完成，构造方法可以有多个参数，每个参数代表一个依赖。调用一个有指定参数的静态工厂方法来创建bean与此差不多，并且这个讨论对于构造方法的参数或者静态工厂方法的参数来说一样。下面展示一个只能使用构造方法注入依赖的类：

```
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

注意这个类没有什么特别的。它只是一个POJO，没有使用容器特定接口，基类或者注解的依赖。

##### Constructor Argument Resolution

只有在bean定义中使用参数类型进行构造方法注入时，构造方法参数解析匹配才会发生。如果一个bean的构造方法参数不存在潜在的冲突，bean定义中构造方法参数定义的顺序就是实例化时提供给合适的构造方法的参数的顺序。考虑下面的类：

```
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

假设`ThingTwo`和`ThingThree`这两个类不存在继承关系，那么就没有潜在的冲突出现。因此，下面的配置能够正常工作，并且你不需要在`<constructor-arg/>`元素中指定构造方法的参数下标或者准确的类型。

```
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

当引用另一个bean时，它的类型是已知的，因此参数匹配可以正常进行（就像前面的例子一样）。如果使用一个简单类型，例如`<value>true</value>`，Spring无法决定这个值是什么类型(比如可以是String或者boolean)，如果没有明确指定那么无法匹配。考虑下面的类：

```
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

1. Constructor argument type matching
在前面的例子中，如果你使用`type`属性明确指定了构造方法参数的类型，那么容器可以对简单的类型进行类型匹配。如下面的例子所示：

```
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

2. Constructor argument index
你也可以使用`index`属性来明确指定构造方法参数的下标，如下所示：

```
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

另外为了解决有多个简单类型时产生的歧义，比如当一个构造方法拥有两个相同类型的参数时，可以通过指定下标来解决歧义问题。

3. Constructor argument name
你也可以使用构造方法的名称来消除歧义，如下所示：

```
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

记住，为了使这些工作可见，你必须在编译代码时打开debug标记，如此Spring可以从构造方法中查找参数名称。如果你不能或者不想使用debug标记编译你的代码，你可以使用 [@ConstructorProperties](https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html) JDK 注解来明确命名你的参数。下面是一个简单的例子：

```
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

>一般编译时会默认打开debug标记，如果不想使用，那么在编译时加上 -g:none 即可

>较高版本的Spring可以自己检测出简单类型，无需手动设置`type`属性

#### Setter-based Dependency Injection

基于setter的依赖注入是通过容器在调用一个无参构造方法或者一个无参静态工厂方法实例化bean后调用setter方法来完成的。

下面的例子展现了一个只可以使用setter进行依赖注入的类。这个类是传统的Java形式，它是一个POJO，没有容器特定接口，基类或者注解的依赖。

```
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

`ApplicationContext`对于管理的bean既支持构造方法注入也支持setter注入。它也支持在一些依赖已经通过构造方法注入后再进行setter注入。你配置依赖以组成一个`BeanDefinition`，同时你可以与`PropertyEditor`实例结合使用来将属性从一个格式转换成另一个格式。但是，大多是Spring使用者不会直接和这些类交互工作（指编程时不会用到），而是使用XML配置文件，注解组件（使用`@Component`, `@Controller`等等来注解类）或者在基于Java的`@Configuration`类上使用`@Bean`注解的方法。这些源文件会在内部转换为`BeanDefinition`实例，然后被使用来加载一个完整的Spring IoC容器实例。

> Constructor-based or setter-based DI?
你可以将基于构造方法的依赖注入和基于setter方法的依赖注入混合使用，这是一个很好的规则，使用构造方法注入必需的依赖以及setter方法注入可选的依赖。注意 [@Required](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-required-annotation) 注解的使用，它可以用在一个setter方法上以使得这个属性成为一个必需的依赖；但是，使用带有验证参数的构造方法注入更加好。
Spring团队一般主张使用构造方法注入，这可以让你将一个应用组件实现为一个不可变对象，并且能够确保必需的依赖不是`null`。更深入的，基于构造方法注入的组件总是能够以一个完全初始化的状态返回给客户端（调用方）代码。作为旁注，一个有很大数量参数的构造方法是一个坏的编码习惯，它意味着这个类好像有许多的职责，并且应该被重构成几个不同的更合适的定位。
setter注入应该只被用作注入可选依赖，这些依赖可以在类中有一个默认值。否则，当代码中每当使用这些依赖都必须执行非空检查。setter注入的一个好处是让这个类的对象可以被再次配置或者在以后再次被注入。[JMX MBeans](https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jmx) 是setter注入的一个很好的用例。
使用DI模式对一些特定的类有很大的意义。有时候，当处理一个没有源码的第三方类时，你可以做出选择。例如，如果第三方类没有暴露任何setter方法，那么你只能使用构造方法注入来进行DI。

##### Dependency Resolution Process

容器按下面的步骤执行bean依赖的解析：

- `ApplicationContext`被创建并且使用描述了所有bean的配置元信息来初始化。配置元信息可以通过XML,Java代码或注解指定。

- 对于每一个bean，它的依赖以属性，构造方法参数，静态工厂方法（如果使用它代替构造方法）的形式被表达。当bean被真正创建时这些依赖被提供给bean。

- 每一个属性或者构造方法参数被设置为一个真实定义的值，或者容器中另一个bean的引用。

- 每一个属性或者构造方法参数的值以指定的格式被转换为那个属性或者构造方法参数的真正类型。默认，Spring可以将以字符串格式提供的值转换为所有的内建类型，例如`int`, `long`, `String`, `boolean`等等。


Spring容器在创建的时候会验证每一个bean的配置。但是，bean的属性本身不会被设置直到这个bean被真正创建。单例[singleton]作用域的bean会进行提前初始化（默认行为），当容器被创建的时候，单例bean也会被创建。关于作用域的信息定义在 [Bean Scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes) 中。 否则，只有当bean被请求的时候才会被真正创建。一个bean的创建可能会暗中导致许多bean的创建，比如bean的依赖以及它的依赖的依赖（等等）被创建以及赋值。注意那些依赖的错误解析可能会在后面出现 —— 也就是被影响的bean第一次创建时。

> 循环依赖 Circular dependencies
如果你主要使用构造方法注入，那么可能会导致一个无法解决的循环依赖场景。
例如：类A在构造方法注入时需要一个类B的实例，并且类B在构造方法注入时也需要一个类A的实例。如果你将类A和B配置为互相注入，Spring IoC容器会在运行时检测出这个循环依赖并且抛出一个`BeanCurrentlyInCreationException`异常。
一个可能的解决方法是修改这些类的源代码，使得它们可以通过setter方法而不是构造方法进行注入。可供代替的，避免使用构造方法注入并且只使用setter注入。换句话说，虽然这不被推荐，但是你可以只在配置循环依赖时使用setter注入。
与一般用例（没有循环依赖）不同，在bean A和B之间的循环依赖强制其中一个在被完全初始化之前注入到另一个中（一个经典的鸡先生还是蛋先生场景）。

```
public class CircularBeanA {
    private CircularBeanB beanB;

    public CircularBeanA(CircularBeanB beanB) {
        this.beanB = beanB;
    }

    public CircularBeanB getBeanB() {
        return beanB;
    }
}
```
```
public class CircularBeanB {
    private CircularBeanA beanA;

    public CircularBeanB(CircularBeanA beanA) {
        this.beanA = beanA;
    }

    public CircularBeanA getBeanA() {
        return beanA;
    }
}
```
```
<bean id="beanA" class="com.shallowinggg.ioc1.entity.CircularBeanA">
    <constructor-arg name="beanB" ref="beanB" />
</bean>

<bean id="beanB" class="com.shallowinggg.ioc1.entity.CircularBeanB">
    <constructor-arg name="beanA" ref="beanA" />
</bean>
```
```
@Test
public void testCircularDependency() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CircularBeanA beanA = context.getBean("beanA", CircularBeanA.class);
    System.out.println(beanA);
}
```
输出如下：
>org.springframework.beans.factory.**BeanCreationException**: Error creating bean with name 'beanA' defined in class path resource [spring-config.xml]: Cannot resolve reference to bean 'beanB' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'beanB' defined in class path resource [spring-config.xml]: Cannot resolve reference to bean 'beanA' while setting constructor argument; nested exception is org.springframework.beans.factory.**BeanCurrentlyInCreationException**: Error creating bean with name 'beanA': Requested bean is currently in creation: **Is there an unresolvable circular reference**?

现在将其修改为setter注入(注意需要一个无参构造方法):
```
public class CircularBeanA {
    private CircularBeanB beanB;
    
    public CircularBeanA() {
    }

    public CircularBeanA(CircularBeanB beanB) {
        this.beanB = beanB;
    }

    public void setBeanB(CircularBeanB beanB) {
        this.beanB = beanB;
    }

    public CircularBeanB getBeanB() {
        return beanB;
    }
}
```
```
public class CircularBeanB {
    private CircularBeanA beanA;
    
    public CircularBeanB() {
    }

    public CircularBeanB(CircularBeanA beanA) {
        this.beanA = beanA;
    }

    public void setBeanA(CircularBeanA beanA) {
        this.beanA = beanA;
    }

    public CircularBeanA getBeanA() {
        return beanA;
    }
}
```
```
<bean id="beanA" class="com.shallowinggg.ioc1.entity.CircularBeanA">
    <property name="beanB" ref="beanB" />
</bean>

<bean id="beanB" class="com.shallowinggg.ioc1.entity.CircularBeanB">
    <property name="beanA" ref="beanA" />
</bean>
```
再次进行测试，输出如下:
```
com.shallowinggg.ioc1.entity.CircularBeanA@73194df
```

> 注意：Spring只能解决单例bean中循环依赖的问题，如果是prototype作用域的bean，那么依然会抛出异常。

```
<bean id="beanA" class="com.shallowinggg.ioc1.entity.CircularBeanA" scope="prototype">
    <property name="beanB" ref="beanB" />
</bean>

<bean id="beanB" class="com.shallowinggg.ioc1.entity.CircularBeanB" scope="prototype">
    <property name="beanA" ref="beanA" />
</bean>
```

输出如下:
>org.springframework.beans.factory.**BeanCreationException**: Error creating bean with name 'beanA' defined in class path resource [spring-config.xml]: Cannot resolve reference to bean 'beanB' while setting bean property 'beanB'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'beanB' defined in class path resource [spring-config.xml]: Cannot resolve reference to bean 'beanA' while setting bean property 'beanA'; nested exception is org.springframework.beans.factory.**BeanCurrentlyInCreationException**: Error creating bean with name 'beanA': Requested bean is currently in creation: **Is there an unresolvable circular reference**?

<br/>
一般来说你可以相信Spring能做正确的事情。它可以在容器加载时检测出配置问题，例如引用一个不存在的bean或者循环引用。Spring会在尽量晚的时间设置属性以及解析依赖，比如当bean真正创建时。这意味着一个正确加载的Spring容器可以更晚的抛出一个异常，在当你需要一个对象时并且创建那个对象或者它的依赖出现了问题 —— 例如，由于缺少或者不合法的属性导致创建bean抛出异常。因此会推迟一些配置问题的可见，这也是为什么Spring的`ApplicationContext`实现会默认提前实例化单例bean。在它们真正需要之前花费一些前期的时间以及内存来创建它们，你能够在`ApplicationContext`创建的时候发现配置问题，而不是在很晚的时候。你也可以覆盖这个默认的行为如此单例bean能够被延迟初始化而不是被提前实例化。

如果没有循环依赖出现，当一个或多个bean被注入到一个依赖的bean中时，每一个bean都会在被注入到依赖bean之前被完全配置。这意味着，如果bean A有一个对bean B的依赖，Spring IoC容器会在调用bean A的setter方法之前先完全配置好bean B。换句话说，这个bean B被实例化（如果不是一个提前实例化的单例），它的依赖被设置并且相关的生命周期方法 (例如一个 [configured init method](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) 或者 [InitializingBean callback method](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)) 被调用。

#### Examples of Dependency Injection

下面的例子使用基于XML的配置元信息来使用setter注入。一部分Spring XML配置文件指定了如下的bean定义：
```
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面的例子展示了相关的`ExampleBean`类:
```
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
```

在前面的例子中，setter被声明以匹配XML文件中指定的属性。下面的例子使用了基于构造方法的依赖注入：
```
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面的例子展示了相关的`ExampleBean`类:
```
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```

在bean定义中指定的构造方法参数被用作为`ExampleBean`的构造方法的参数。

现在考虑一个这个例子的变种，代替使用一个构造方法，Spring被告知调用一个静态工厂方法来返回这个对象的实例：
```
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

下面的例子展示了相关的`ExampleBean`类:
```
public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```

这个静态工厂方法的参数由` <constructor-arg/>`提供，与构造方法的使用完全相同。通过讲台方法返回的类的类型可以与包含这个静态方法的类的类型不同（虽然在这个例子中相同）。一个实例（非静态）工厂方法可以以一个本质上相同的形式使用（除了使用`factory-bean`属性代替`class`属性），所以我们不再这里讨论这些细节。

### 1.4.2. Dependencies and Configuration in Detail

正如上一节中提到的，你可以定义bean的属性以及构造方法参数来引用其他的bean或者是一个内联的值。Spring中基于XML的配置元信息在`<property/>`和`<constructor-arg/>`元素中支持子元素类型以实现这个目标。

#### Straight Values (Primitives, Strings, and so on)

`<property/>`元素的`value`属性以一种人类可阅读的形式指定一个属性或者构造方法参数。Spring的 [conversion service](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-ConversionService-API) 被使用来将这些值从 `String` 转换为属性或者参数的真实类型。下面的例子展示了被设置的各种值：
```
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="masterkaoli"/>
</bean>
```

下面的例子使用了 [p-namespace](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-p-namespace) 来提供更加简明的XML配置:

```
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="masterkaoli"/>

</beans>
```

前面的XML更加简明。但是，错误会在运行时发现而不是设计时发现，除非你使用一个IDE (例如 [IntelliJ IDEA](http://www.jetbrains.com/idea/) 或者 [Spring Tool Suite](https://spring.io/tools/sts)) ，它们支持在创建bean定义时自动完成属性配置。这样的IDE的帮助被高度推荐使用。

你可以像下面这样配置一个 `java.util.Properties` 实例:

```
<bean id="mappings"
    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

Spring容器会使用JavaBean的`PropertyEditor`机制将`<value/>`元素内部的文本转换为一个`java.util.Properties`实例。这是一个很棒的捷径，并且这也是很少的Spring团队更喜欢使用嵌套的`<value/>`元素而不是`value`属性风格的地方。

###### The `idref` element

`idref`元素是一个简单的错误预防的方式，通过将容器中另一个bean的`id`（作为一个字符串值而不是一个引用）传输给一个`<constructor-arg/>`或者`<property/>`元素。下面的例子展示了如何使用它：

```
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
```

前面的bean定义片段和下面的片段在运行时完全相同：

```
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

第一种形式比第二种更好，因为使用`idref`标记可以让容器在部署时验证引用的bean是否真正存在。在第二个变种中，当它被传输给`client` bean的 `targetName`属性时没有任何验证会被执行。错误只会在`client` bean真正实例化的时候才被发现（与大多数致命的结果一起）。如果这个`client` bean是一个 [prototype](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes) bean, 这个错误以及引发的异常可能会在容器部署很久以后才会被发现。


>`idref`元素的`local`属性在Spring 4.0的beans XSD中不再被支持，当更新到Spring 4.0时注意修改存在的`idref`的`local`引用。

`<idref/>`元素带有值的一个常见使用（至少在Spring 2.0版本之前）是在一个`ProxyFactoryBean` bean定义中的[AOP interceptors](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pfb-1) 配置中。当你指定拦截器的名字时使用`<idref/>`元素，以防错误拼写了拦截器的ID。

> 注意：如果初次使用`idref`元素可能会将其误用，比如使用它来直接引用另一个bean，但是idref只会作为一个字符串值使用。

```
public class IdRef {
    private CircularBeanA beanA;
    private String beanName;

    public String getBeanName() {
        return beanName;
    }

    public void setBeanName(String beanName) {
        this.beanName = beanName;
    }

    public CircularBeanA getBeanA() {
        return beanA;
    }

    public void setBeanA(CircularBeanA beanA) {
        this.beanA = beanA;
    }
}
```
```
<bean id="bean" class="com.shallowinggg.ioc1.entity.CircularBeanA" />

<bean id="idref" class="com.shallowinggg.ioc1.entity.IdRef">
    <property name="beanA">
        <idref bean="bean" />
    </property>
</bean>
```
```
@Test
public void testIdRef() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    IdRef ref = context.getBean("idref", IdRef.class);
    System.out.println(ref.getBeanA());
}
```
输出如下：
>org.springframework.beans.factory.BeanCreationException: Error creating bean with name **'idref'** defined in class path resource [spring-config.xml]: Initialization of bean failed; nested exception is org.springframework.beans.ConversionNotSupportedException: Failed to convert property value of type 'java.lang.String' to required type 'com.shallowinggg.ioc1.entity.CircularBeanA' for property 'beanA'; nested exception is java.lang.IllegalStateException: Cannot convert value of type 'java.lang.String' to required type 'com.shallowinggg.ioc1.entity.CircularBeanA' for property 'beanA': no matching editors or conversion strategy found

进行如下修改：
```
<bean id="idref2" class="com.shallowinggg.ioc1.entity.IdRef">
    <property name="beanName">
        <idref bean="bean" />
    </property>
</bean>
```
```
@Test
public void testIdRef() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    IdRef ref = context.getBean("idref", IdRef.class);
    System.out.println(ref.getBeanName());
}
```
成功运行。

#### References to Other Beans (Collaborators)

ref元素是`<constructor-arg/>` 或`<property/>`元素内的的最终结点。你可以用它设置bean的指定属性的值，通过引用容器中其他的bean。被引用的bean是被设置属性的bean的一个依赖，并且它在被注入之前会被先初始化（如果它是一个单例bean，那么它可能已经被初始化了）。所有的引用最终都是另一个对象的引用。作用域以及验证依赖于你是否通过`bean`,`local`,parent`属性指定了ID或者名称。

通过`<ref/>`标签的`bean`属性指定目标bean是最常用的方式，也允许引用相同容器或者父容器中的其他bean，不管是不是在同一个XML文件中。`bean`属性的值应当与目标bean的`id`属性相同或者与`name`属性中的一个相同，下面的例子展示了如何使用`ref`元素：

```
<ref bean="someBean"/>
```
可以通过`parent`属性来创建一个指向当前容器的父容器中的bean的引用。`parent`属性的值需要与目标bean的`id`属性相同或者与`name`属性中的一个相同。目标bean必须是在当前容器的父容器中。当你有一个继承层次的容器并且你想要使用代理包装一个父容器中的bean，这个代理的名字和父容器的bean名字相同时，你应该使用`parent`属性。下面的的例子展示了如何使用`parent`属性：

```
<!-- in the parent context -->
<bean id="accountService" class="com.something.SimpleAccountService">
    <!-- insert dependencies as required as here -->
</bean>
```
```
<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

>`ref`元素的`local`属性在Spring 4.0的beans XSD中不再被支持，当更新到Spring 4.0时注意修改存在的`ref`的`local`引用。

#### Inner Beans

使用`<property/>`或者`<constructor-arg/>`元素内的`<bean/>`元素可以定义一个内部bean，如下所示:

```
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

一个内部bean定义不需要ID或者名称。如果指定了，容器也不会使用这个值作为一个标识符。容器还会在创建时忽略它的scope标记，因为内部bean总是匿名的并且随着外部bean的创建而被创建，直接获取内部bean或者将内部bean注入其他的bean中是不可能的。

作为一个特例，从一个自定义作用域中接受一个销毁回调是可能做到的 —— 例如，在一个单例bean中的request作用域的内部bean。内部bean实例的创建与包含它的bean绑定，但是销毁回调可以让它参与到request作用域的生命周期中。这不是一个常见的情况，内部bean一般都会和它的外部bean共享作用域。

#### Collections

`<list/>`, `<set/>`, `<map/>`,和 `<props/>`元素可以用来设置拓展自Java `collection`的`List`, `Set`, `Map`, 以及 `Properties`类型的属性。

```
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

一个map的键或值的值可以是下面的一种：
```
bean | ref | idref | list | set | map | props | value | null
```

##### Collection Merging

Spring容器也支持集合合并。一个应用开发者可以定义一个父`<list/>`, `<set/>`, `<map/>`和 `<props/>`元素，然后让子`<list/>`, `<set/>`, `<map/>`和 `<props/>`元素继承父bean并且覆盖父集合中的值。也就是子集合的值是合并父集合与子集合的产物。

本节讨论了父子bean机制的合并问题。如果不熟悉父子bean定义，可以在查看下面的内容前先阅读[相关章节](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-child-bean-definitions)。

下面的例子展示了集合合并：

```
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

注意子bean中`adminEmails`属性的`<props/>`元素，它使用了`merge=ture`属性。当子bean在容器中被解析以及实例化，结果实例拥有一个叫做`adminEmails`的Properties集合，它合并了父`adminEmails`集合以及子`adminEmails`集合中的值。
下面是合并结果：

```
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
```

子Properties集合值从父`<props/>`中继承了所有的值，并且子集合中的`support`值覆盖了父集合中的值。

`<list/>`, `<set/>`, `<map/>`集合类型的合并行为与此类似。不过`<list/>`元素是一个特例，它维护了与List集合类型（一个顺序集合的值的概念）相关联的语义。父集合中的值会排在子集合中的值前面。而在Map,Set和Properties集合类型中不存在排序，因此，没有与容器内部使用的Map,Set和Properties集合实现类相关联的排序语义。

```
public class CollectionBean {
    private List<Integer> list;

    public List<Integer> getList() {
        return list;
    }

    public void setList(List<Integer> list) {
        this.list = list;
    }
}
```
```
<bean id="parent" abstract="true" class="com.shallowinggg.ioc1.entity.CollectionBean">
    <property name="list">
        <list>
            <value>1</value>
            <value>2</value>
            <value>3</value>
            <value>4</value>
        </list>
    </property>
</bean>

<bean id="child" class="com.shallowinggg.ioc1.entity.CollectionBean" parent="parent">
    <property name="list">
        <list merge="true">
            <value>3</value>
            <value>4</value>
        </list>
    </property>
</bean>
```
```
@Test
public void testListMerge() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CollectionBean bean = context.getBean("child", CollectionBean.class);
    System.out.println(bean.getList());
}
```
输出如下：
>[1, 2, 3, 4, 3, 4]

##### Limitations of Collection Merging

不能合并不同的集合类型（例如一个Map和一个List），如果这样做会抛出异常。`merge`属性必须在更低的、继承的子bean中指定，在父集合定义中设置`merge`属性不会起作用。

```
<bean id="parent" abstract="true" class="com.shallowinggg.ioc1.entity.CollectionBean">
    <property name="list">
        <list merge="true">
            <value>1</value>
            <value>2</value>
            <value>3</value>
            <value>4</value>
        </list>
    </property>
</bean>

<bean id="child2" class="com.shallowinggg.ioc1.entity.CollectionBean" parent="parent">
    <property name="list">
        <list>
            <value>3</value>
            <value>4</value>
        </list>
    </property>
</bean>
```
```
@Test
public void testCollectionMergeLimit() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CollectionBean bean = context.getBean("child2", CollectionBean.class);
    System.out.println(bean.getList());
}
```
输出如下：
>[3, 4]

##### Strongly-typed collection

Java 5引入了泛型特性，因此可以使用强类型集合，定义一个只包含String类型的元素的集合是可以做到的。如果使用Spring依赖注入将一个强类型集合注入到一个bean中，可以利用Spring提供的类型转换机制。在数据被增加到集合之前，它会被转换为合适的类型。

```
public class SomeClass {

    private Map<String, Float> accounts;

    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }
}
```
```
<beans>
    <bean id="something" class="x.y.SomeClass">
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>
    </bean>
</beans>
```

在bean`something`的`accounts`属性准备注入时，关于强类型的 `Map<String, Float>`的元素的泛型信息能够通过反射获取。因此，Spring能够识别出`Float`类型，然后将字符串值(9.99, 2.75, 和3.99)转换为`Float`类型。

#### Null and Empty String Values

Spring会将空参数的属性视作一个空的字符串""。比如下面的例子中会将`email`属性设置为空的字符串""。

```
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
```
前面的例子等同于下面的Java代码：
```
exampleBean.setEmail("");
```

`<null/>` 元素处理 `null` 值。
```
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

前面的例子等同于下面的Java代码：
```
exampleBean.setEmail(null);
```

#### XML Shortcut with the p-namespace

`p-namespace`可以让你使用`bean`元素的属性（代替嵌套的`<property/>`元素）来描述组合bean属性值。

Spring支持[使用 namespaces](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#xsd-schemas)拓展配置的格式，这基于XML Schema定义。这个章节中讨论的`bean`配置格式被定义在一个XML Schema文档中。但是， `p-namespace`没有被定义在一个XSD文件中并且只存在于Spring core中。

下面的例子展示了两个XML片段（第一个使用标准XML格式，第二个使用p-namespace），它们有着相同的结果：

```
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="classic" class="com.example.ExampleBean">
        <property name="email" value="someone@somewhere.com"/>
    </bean>

    <bean name="p-namespace" class="com.example.ExampleBean"
        p:email="someone@somewhere.com"/>
</beans>
```

这个例子展示了bean定义中一个叫做`email`的p-namespace调用。它告诉Spring要包含一个属性声明，

下面的例子包含了两个bean定义，它们都引用了另一个bean：

```
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="john-classic" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="spouse" ref="jane"/>
    </bean>

    <bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/>

    <bean name="jane" class="com.example.Person">
        <property name="name" value="Jane Doe"/>
    </bean>
</beans>
```

>p-namespace没有标准的XML格式灵活。例如，声明一个属性引用需要以ref结尾，而标准的XML格式不需要这么做。我们建议你小心选择你自己的方式，并且和你的团队成员交流以避免同时使用这几种格式。

#### XML Shortcut with the c-namespace

与[XML Shortcut with the p-namespace](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-p-namespace)相似，在Spring 3.1中引入的c-namespace，允许内联属性来配置构造方法参数而不是使用嵌套的`constructor-arg`元素。

下面使用`c:`namespace的例子与前面 [Constructor-based Dependency Injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-constructor-injection) 中的例子相同：

```
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="beanTwo" class="x.y.ThingTwo"/>
    <bean id="beanThree" class="x.y.ThingThree"/>

    <!-- traditional declaration with optional argument names -->
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg name="thingTwo" ref="beanTwo"/>
        <constructor-arg name="thingThree" ref="beanThree"/>
        <constructor-arg name="email" value="something@somewhere.com"/>
    </bean>

    <!-- c-namespace declaration with argument names -->
    <bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

</beans>
```

The c: namespace uses the same conventions as the p: one (a trailing -ref for bean references) for setting the constructor arguments by their names. Similarly, it needs to be declared in the XML file even though it is not defined in an XSD schema (it exists inside the Spring core).

有一些很少的情况，构造方法的参数的名称无法获取（一般是由于编译时没有使用debug信息），你可以使用参数下标来回调，例如：

```
<!-- c-namespace index declaration -->
<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
    c:_2="something@somewhere.com"/>
```

>由于XML的语法，index需要在前面增加一个_，因为XML的属性名称无法以一个数字开头（即使一些IDE允许）。index符号也可以在<constructor-arg> 元素中使用，但是并不常用。

实际上，构造方法的解析[机制](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-ctor-arguments-resolution)在匹配参数时是相当有效的，所以除非你确实需要使用，否则我们建议在的你配置文件使用name符号。

#### Compound Property Names

你可以使用一个组合的或者嵌套的property，只要除了最后一个property以外的property不为null。

```
<bean id="something" class="things.ThingOne">
    <property name="fred.bob.sammy" value="123" />
</bean>
```

bean`something`有一个`fred`属性，`fred`属性有一个`bob`属性，`bob`属性有一个`sammy`属性，并且最后的`sammy`属性被设置为123。为了能让它工作，在bean被实例化之后`fred`以及`bob`属性一定不能为空，否则将会抛出一个NullPointerException。

```
package ioc.entity;

public class CompoundProperty {
    private User user;

    public CompoundProperty() {
        user = new User();
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}
```

```
    <bean id="compoundProperty" class="ioc.entity.CompoundProperty">
        <property name="user.username" value="root" />
        <property name="user.password" value="root" />
    </bean>
```

```
    @Test
    public void testCompoundProperty() {
        CompoundProperty bean = context.getBean("compoundProperty", CompoundProperty.class);
        System.out.println(bean.getUser());
    }
```

输出如下：
>User[username=root, password=root]

注意`CompoundProperty`类的无参构造函数中实例化了user变量，如果不这样的话那么user就是null，对一个null对象调用setter方法设置值会抛出NPE。

### Using depends-on

有时候bean之间的依赖关系不是直接的。一个例子是一个类的静态初始化器需要被触发，比如数据库驱动注册。此时`<ref/>`元素无法起到作用，需要使用`depends-on`属性。

```
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />
```

为了表达一个bean的初始化需要依赖多个其他bean的初始化，需要在`depends-on`属性中提供一系列bean名称，使用逗号，分号或者空格分隔。

```
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```

>`depend-on`属性可以指定依赖的初始化顺序，并且对于一个[单例](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton)bean，也可以指定相关依赖的销毁时间。定义`depends-on`关系的依赖bean首先被销毁，比被依赖的bean销毁的更早。因此，`depends-on`也能够控制销毁顺序。

```
package ioc.entity;

public class DependBean {
    public void init() {
        System.out.println("DependBean init");
    }

    public void destroy() {
        System.out.println("DependBean destroy");
    }
}

package ioc.entity;

public class DependOnBean {
    public void init() {
        System.out.println("DependOnBean init");
    }

    public void destroy() {
        System.out.println("DependOnBean destroy");
    }
}
```

```
<bean id="dependOn" class="ioc.entity.DependOnBean" destroy-method="destroy" init-method="init" />
<bean id="depend" class="ioc.entity.DependBean" destroy-method="destroy" init-method="init" 
depends-on="dependOn" />
```

```
@Test
public void testDependOn() throws Exception {
    DependBean bean = context.getBean("depend", DependBean.class);
    ((ClassPathXmlApplicationContext)context).close();
}
```

>DependOnBean init
DependBean init
DependBean destroy
DependOnBean destroy

### 1.4.4. Lazy-initialized Beans

默认的`ApplicationContext`实现会在初始化时创建以及配置所有的[单例](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton)bean。提前实例化是有用的，因为配置文件或者环境中的错误会被立刻发现，而不是在几小时甚至几天后才被发现。如果你不需要提前实例化，可以阻止提前实例化单例bean，通过将这个bean的定义标记为lazy-initialized。一个延迟初始化的bean告知容器当它首次被请求时才创建它的实例，而不是在容器初始化时。

在XML配置文件中，可以通过`<bean/>`元素的`lazy-init`属性来控制这个行为，如下所示：

```
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```

当前面的配置文件被ApplicationContext解析时，延迟初始化的bean将不在ApplicationContext启动时被提前实例化，而非延迟的bean继续提前实例化。

不过，当一个延迟初始化的bean是另一个单例bean（这个单例bean没有设置`lazy-init`）的依赖时，它将不再被延迟初始化，ApplicationContext会在初始化时就创建它，因为必须要满足单例bean的依赖。

也可以通过`<beans/>`元素的`default-lazy-init`属性来控制容器级别的延迟初始化。

```
<beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
</beans>
```

### 1.4.5. Autowiring Collaborators

Spring容器可以在组合bean之中自动注入依赖。你可以让Spring为你的bean自动解析它所需的依赖bean，通过检查`ApplicationContext`中的内容。自动注入有下面的好处：

- 自动注入可以显著减少指定属性或者构造方法参数的需要。（其他机制比如bean模板在这个方面也有价值）[1.7. Bean Definition Inheritance](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-child-bean-definitions)
- 自动注入可以在你的对象演变的时候更新配置。例如，如果你需要向一个类增加一个依赖，那个依赖可以被自动满足而不需要你去修改配置文件。因此自动注入在开发的过程中是有用的。

当使用基于XML的配置元信息(see [Dependency Injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-collaborators))时，你可以为一个bean定义指定自动注入模式，通过使用`<bean/>`元素的`autowire`属性。自动注入功能有四个模式，下面的表描述了这四个模式：

|模式	|解释|
|-|-|
|no|(默认) 不使用自动注入。bean定义必须通过ref元素来定义。对于大的部署改变默认配置是不推荐的，因为确定的合作者给予了更好的控制以及清晰度。在某种程度上，它为一个系统的结构定义了文档。|
|byName|通过属性名称自动注入。Spring为一个需要自动注入的属性寻找一个与它名称相同的bean。例如，如果一个bean定义被设置为通过名称自动注入并且它包含了一个叫做`master`的属性（也就是它拥有一个`setMaster(..)`方法），Spring会寻找一个叫做`master`的bean定义并且使用它来设置这个属性|
|byType|如果容器中存在与一个bean的属性的类型相同的bean，那么将它自动注入到这个属性中。如果有不止一个满足条件的bean，将会抛出异常，表示你不能为这个bean使用byType的自动注入。如果没有符合的bean，那么什么也不会发生（这个属性不会被设置）|
|constructor|与byType类似，但是应用到构造方法的参数上。|

使用byType或者constructor自动注入模式，你可以注入数组或者集合。在这种情况下，所有容器中符合期待类型的候选者被提供以满足这个依赖。如果key类型为String，那么你可以自动注入一个强类型的Map实例。一个自动注入的Map实例的值包含了所有满足条件的bean实例，并且Map实例的key包含了相关bean的名称。

#### Limitations and Disadvantages of Autowiring

自动注入最好是在整个项目中使用。如果不在整个项目中全部使用`autowire`，只在几个bean中使用它会让人产生疑惑。

考虑下面几个自动注入的限制以及缺点：

- 在`property` 和 `constructor-arg`中主动设置的依赖会覆盖`autowire`。并且，自动注入无法注入基本类型，String，Class，数组等简单类型。
- 自动注入比手动注入的准确率更低。
- 注入的信息不能被用来生成文档的Spring组件获取
- 如果只需要一个值，但是容器中有多个符合的，会抛出异常

有下面几种解决方案：
- 使用手动注入，禁止自动注入
- 将bean的`autowire-candidate`属性设为false，避免将它注入给其他bean
- 设置bean的`primary`属性为true，当有多个符合的bean时，优先选择此bean
- 使用注解配置，在[Annotation-based Container Configuration](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-annotation-config)中介绍

#### Excluding a Bean from Autowiring

你可以将一个bean从自动注入的候选者中派出。在Spring XML配置文件中，将bean的`autowire-candidate`属性设为false。然后容器就不会将指定的bean提供给自动注入组件（包括注解形式的配置，例如[`@Autowired`](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation))）。

> `autowire-candidate`属性只会影响`byType`类型的自动注入，通过名称的精确引用不受影响。作为结果，通过名称的自动注入能够成功执行。

可以通过模式匹配限制自动注入的候选bean。`<beans/>`元素的`default-autowire-candidates`属性接受一个或多个模式。例如，如果想要限制以`Repository`结尾的bean，提供一个`*Repository`值即可。如果要提供多个模式，需要使用逗号分隔。如果在`<bean/>`元素中主动设置了`autowire-candidate`属性，那么不受模式匹配的影响。

当你你不想要一些bean被自动注入到其他bean时，这些技术是很有用的。它也不意味着被排除的bean本身无法使用自动注入，而是这个bean不是其他bean进行自动注入时的候选者。

####示例

1. 使用byName
```
public class User {
    private String username;
    private String password;

    public User() {
        this("default", "default");
    }

    public User(String username) {
        this(username, "default");
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public boolean equals(Object obj) {
        if(obj==null) {
            return false;
        }
        if(!(obj instanceof User)) {
            return false;
        }
        User user = (User)obj;
        return username.equals(user.username) && password.equals(user.password);
    }

    @Override
    public int hashCode() {
        return Objects.hash(username, password);
    }

    @Override
    public String toString() {
        return "User[username=" + username + ", password=" + password + "]";
    }
}
```
```
public class CompositeBean {
    private User user;

    public CompositeBean() {
    }

    public CompositeBean(User user) {
        this.user = user;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}
```
```
<bean id="user" class="com.shallowinggg.ioc1.entity.User" />

<bean id="byName" class="com.shallowinggg.ioc1.entity.CompositeBean" autowire="byName" />
```
```
@Test
public void testAutowireByName() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CompositeBean bean = context.getBean("byName", CompositeBean.class);
    System.out.println(bean.getUser());
}
```
输出如下：
>User[username=default, password=default]

2. byType
```
<bean id="byType" class="com.shallowinggg.ioc1.entity.CompositeBean" autowire="byType" />
```
```
@Test
public void testAutowireByType() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CompositeBean bean = context.getBean("byType", CompositeBean.class);
    System.out.println(bean.getUser());
}
```
输出如下：
>User[username=default, password=default]

3. constructor
```
<bean id="constructor" class="com.shallowinggg.ioc1.entity.CompositeBean" autowire="constructor"/>
```
```
@Test
public void testAutowireByConstructor() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CompositeBean bean = context.getBean("constructor", CompositeBean.class);
    System.out.println(bean.getUser());
}
```
输出如下：
>User[username=default, password=default]

下面测试这些模式的缺陷。
1. byType
```
<bean id="user" class="com.shallowinggg.ioc1.entity.User" />
<bean id="user2" class="com.shallowinggg.ioc1.entity.User">
    <property name="username" value="user2" />
</bean>
<bean id="byType" class="com.shallowinggg.ioc1.entity.CompositeBean" autowire="byType" />
```
```
@Test
public void testAutowireByTypeDisadvantage() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CompositeBean bean = context.getBean("byType", CompositeBean.class);
}
```
输出如下：
>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'byType' defined in class path resource [spring-config.xml]: Unsatisfied dependency expressed through bean property 'user'; nested exception is org.springframework.beans.factory.**NoUniqueBeanDefinitionException**: No qualifying bean of type 'com.shallowinggg.ioc1.entity.User' available: **expected single matching bean but found 2: user,user2**

2. constructor
```
@Test
public void testAutowireConstructorDisadvantage() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CompositeBean bean = context.getBean("constructor", CompositeBean.class);
}
```
输出如下：
>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'byType' defined in class path resource [spring-config.xml]: Unsatisfied dependency expressed through bean property 'user'; nested exception is org.springframework.beans.factory.**NoUniqueBeanDefinitionException**: No qualifying bean of type 'com.shallowinggg.ioc1.entity.User' available: **expected single matching bean but found 2: user,user2**

### 1.4.6. Method Injection

在大多数的应用中，容器中大多数的bean时单例bean。当一个单例bean需要另一个单例bean或者一个非单例bean需要另一个非单例bean，你一般能通过定义一个属性来处理依赖问题。但是如果bean的生命周期不同将会引发问题。考虑下面的情况，如果一个单例bean A在调用自己的方法时需要使用一个非单例bean B，容器只会创建A一次，因此只有一次机会能够设置B。当每次A需要B的时候，容器无法每次都提供B的一个新实例。

解决方法就是放弃一些IoC的规则，可以让A实现`ApplicationContextAware`接口来感知到容器，然后调用容器的`getBean()`方法来获取B的新实例。

```
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```

但是这种方法并不好，因为会增加企业逻辑代码与Spring之间的耦合。另一种方法是使用方法注入，这是Spring IoC提供的一个高级特性，能够更干净的处理这个问题。

更多信息见 [Method Injection](https://spring.io/blog/2004/08/06/method-injection/)。

#### Lookup Method Injection

Lookup方法注入是容器提供的一个功能，它可以覆盖容器中的bean实例的方法并且返回容器中另一个命名bean的实例。lookup一般涉及一个原型bean，在[前面的章节中](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-method-injection)描述过原型。Spring框架实现方法注入的原理是通过使用CGLIB库的字节码生成来产生一个子类以覆盖方法。

- 为了让动态子类能够工作，需要覆盖方法的bean的类不能定义为final，并且这个方法也不能定义为final。
- 单元测试一个拥有抽象方法的类需要你自己去实现这个类的子类，以提供这个抽象方法的实现。
- 方法需要组件扫描来查找，这也需要一个真正的类，即不是抽象类
- 一个更深的关键限制是lookup方法无法应用到工厂方法，特别是注解模式下配置类的使用`@Bean`注解的方法，因为在这种情况下，Spring并不控制实例的创建，因此也无法产生一个运行时生成的子类。

在下面的`CommandManager`类片段中，Spring容器动态覆盖了`createCommand() `方法的实现。`CommandManager`类没有任何Spring依赖，如下所示：

```
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

使用`lookup`特性的方法需要满足下面的特征：
```
<public|protected> [abstract] <return-type> theMethodName(no-arguments);
```

如果这个方法是一个abstrct方法，那么动态生成的子类会实现这个方法，否则重写这个方法。考虑下面的例子：

```
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
    <!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

叫做`commandManager`的bean在每次需要一个新实例时都会调用`createCommand()`方法创建，你必须小心部署`myCommand`bean，如果确实需要的话将它作为一个原型bean。如果它是也给单例bean，那么每次都会返回`myCommand`bean的同一个实例。

如果使用注解配置，那么可以使用`Lookup`注解，如下所示：

```
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

或者通过lookup方法声明的返回类型来自动匹配：

```
public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
```

注意你一般需要在一个真实的子类实现上使用这样的lookup注解，为了能够让它与Spring的组件扫描规则像兼容，因为如果使用`component scanning`扫描包中的类，那么它会**自动忽略掉抽象类**。当然，如果明确指定这个类或者注册这个类，不会应用这个规则。

>另一种获取不同作用域的bean方法是`ObjectFactory`/ `Provider`注入点。查看[Scoped Beans as Dependencies](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-other-injection)。你可能会发现`ServiceLocatorFactoryBean` (在 `org.springframework.beans.factory.config` 包中)也十分有用。

##### 示例
```
public interface Command {
    void setState(Object state);

    Object execute();
}

public class AsyncCommand implements Command {
    private Object state;

    @Override
    public void setState(Object state) {
        this.state = state;
    }

    @Override
    public Object execute() {
        return null;
    }
}
```
```
public abstract class CommandManager {
    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        System.out.println(command);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```
```
<bean id="command" class="com.shallowinggg.ioc1.entity.AsyncCommand" scope="prototype" />

<bean id="commandManager" class="com.shallowinggg.ioc1.entity.CommandManager">
    <lookup-method name="createCommand" bean="command" />
</bean>
```
```
@Test
public void testLookup() {
    ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
    CommandManager manager = context.getBean(CommandManager.class);
    manager.process(1);
    manager.process(2);
}
```
输出如下：
>com.shallowinggg.ioc1.entity.AsyncCommand@7502291e
com.shallowinggg.ioc1.entity.AsyncCommand@17aad511


#### Arbitrary Method Replacement

一个比lookup更少会用到的方法注入是Arbitrary Method Replacement，它可以使用另一个实现来替换bean中任意的方法。你可以跳过本节剩余的部分直到你需要这项功能时。

使用基于XML的配置元数据，你可以使用`replaced-method`元素以使用另一个方法实现来替换一个已经存在的方法实现。考虑下面的类，我们想要覆盖它的`computeValue`方法：
```
public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
```

使用实现`org.springframework.beans.factory.support.MethodReplacer`接口的类来提供一个新的方法实现，如下所示：

```
/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
```

bean定义需要使用类似下面例子的方法配置：

```
<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
    <!-- arbitrary method replacement -->
    <replaced-method name="computeValue" replacer="replacementComputeValue">
        <arg-type>String</arg-type>
    </replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
```

你可以在`<replaced-method/> `元素中使用一个或者多个`<arg-type/>`元素来表示需要被覆盖的方法的方法签名，只有当方法被重载并且类中存在该方法的多个变种时才需要指定。为了方便，String类型的参数可以使用全限定类名的字串，例如下面的例子都能匹配`java.lang.String`：

```
java.lang.String
String
Str
```

因为参数的数量通常足够区分每个可能的选择，这个捷径可以节省许多命名。
