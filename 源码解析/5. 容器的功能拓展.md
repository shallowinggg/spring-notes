经过前面几章的分析，相信对Spring中的容器功能有了简单的了解，在前面的章节我们一直以`BeanFactory`接口以及它的默认实现类`XmlBeanFactory`为例进行分析，但是，Spring中还提供了另一个接口`ApplicationContext`，用于拓展`BeanFactory`中现有的功能。

`ApplicationContext`和`BeanFactory`两者都是用于加载bean的，但是相比之下，`ApplicationContext`提供了更多的拓展功能，简单一点说：`ApplicationContext`包含`BeanFactory`的所有功能。通常建议比`BeanFactory`优先，除非在一些限制的场合，比如字节长度对内存有很大的影响时(Applet)。绝大多数“典型的”企业应用和系统，`ApplicationContext`就是你需要使用的。

使用ApplicationContext方式加载xml：
```
ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
```

同样，我们还是以`ClassPathXmlApplicationContext`作为切入点，开始对整体功能进行分析。

```
public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
   this(new String[] {configLocation}, true, null);
}

// 加载多个配置文件
public ClassPathXmlApplicationContext(String... configLocations) throws BeansException {
   this(configLocations, true, null);
}

public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
      throws BeansException {

   super(parent);
   setConfigLocations(configLocations);
   if (refresh) {
      refresh();
   }
}
```

设置路径是必不可少的步骤，`ClassPathXmlApplicationContext`可以将配置文件路径以数组的方法传入，`ClassPathXmlApplicationContext`可以对数组进行解析并进行加载。而对于解析及功能都在`refresh`中实现。

## 1. 设置配置路径

```
public void setConfigLocations(String... locations) {
   if (locations != null) {
      Assert.noNullElements(locations, "Config locations must not be null");
      this.configLocations = new String[locations.length];
      for (int i = 0; i < locations.length; i++) {
         // 解析路径
         this.configLocations[i] = resolvePath(locations[i]).trim();
      }
   }
   else {
      this.configLocations = null;
   }
}
```

此函数用于解析给定的路径数组，如果数组中包含特殊符号，如${var}，那么在`resolvePath`中会搜寻匹配的系统变量并替换。

## 2. 拓展功能

设置了路径之后，便可以根据路径做配置文件的解析以及各种功能的实现了。可以说`refresh`中包含了`ApplicationContext`中提供的全部功能，而且此函数的逻辑非常清晰明了，是我们很容易分析对应的层次及逻辑。

```
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      // 准备上下文环境
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      // 初始化beanFactory，并进行xml文件读取
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      // 对BeanFactory进行各种功能填充
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         // 子类覆盖此方法进行额外的处理
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         // 调用注册的BeanFacoty后置处理器
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         // 注册BeanPostProcessor后置处理器
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         // 为上下文初始化Message源，及不同的语言消息体，国际化处理
         initMessageSource();

         // Initialize event multicaster for this context.
         // 初始化应用事件广播器
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         // 在此类中初始化指定的特殊bean
         onRefresh();

         // Check for listener beans and register them.
         // 注册监听器
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         // 实例化所有的非延迟加载的单例
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         // 完成刷新过程
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn("Exception encountered during context initialization - " +
                  "cancelling refresh attempt: " + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
```

下面概括一下`ClassPathXmlApplicationContext`初始化的步骤，并从中解释一下它为我们提供的功能。

1. 初始化前的准备工作，例如对系统属性或者环境变量进行准备以及验证。
在某些情况下项目的使用需要读取某些系统变量，而这个变量的设置很可能会影响系统的正确性，那么`ClassPathXmlApplicationContext`为我们提供的这个准备函数就非常重要，他可以在Spring启动的时候提前对必须的变量进行存在性验证。

2. 初始化BeanFactory，并进行xml文件读取
之前提到`ClassPathXmlApplicationContext`包含`BeanFactory`所提供的一切功能，那么在这一步骤中将会复用`BeanFactory`中的配置文件读取解析及其他功能 ，这一步之后，`ClassPathXmlApplicationContext`实际上就已经包括了`BeanFactory`所提供的功能，也就是可以进行bean的提取等基本操作了。

3. 对BeanFactory进行各种功能填充

```
@Qualifier
@Autowired
```

应该是非常熟悉的注解，这两个注解正是在这一步骤中增加的支持

4. 子类覆盖方法做额外的处理

5. 激活各种`BeanFactory`处理器

6. 注册`BeanPostProcessor`后处理器，这里只是注册，真正调用的时候在getBean

7. 为上下文初始化`MessageSource`，对不同的语言进行国际化处理

8. 初始化应用事件广播器

9. 留给子类初始化其他bean

10. 在所有注册的bean中查找监听器bean，注册到消息广播器中

11. 初始化剩余的单例(非延迟初始化的)

12. 完成刷新过程

## 3. 环境准备

`prepareRefresh`函数主要是做些准备工作，例如对系统属性以及环境变量的初始化及验证。

```
protected void prepareRefresh() {
   // 记录启动时间
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);

   if (logger.isInfoEnabled()) {
      logger.info("Refreshing " + this);
   }

   // Initialize any placeholder property sources in the context environment
   // 初始化上下文环境中的占位符属性资源
   // 空实现，留待子类实现
   initPropertySources();

   // Validate that all properties marked as required are resolvable
   // see ConfigurablePropertyResolver#setRequiredProperties
   // 验证需要的属性是否都存在
   getEnvironment().validateRequiredProperties();

   // Allow for the collection of early ApplicationEvents,
   // to be published once the multicaster is available...
   this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();
}
```

我们探索下各个函数的功能。

1. `initpropertySources`正符合Spring的开放式结构设计，给用户最大拓展Spring的能力。用户可以根据自己的需要重写此方法，并在方法中进行个性化的属性处理及设置。
```
protected void initPropertySources() {
   // For subclasses: do nothing by default.
}
```
2. `validateRequiredProperties`则是对必需的属性进行验证。默认情况下所有的属性都不是必需的，可以通过`ConfigurablePropertyResolver#setRequiredProperties`方法增加必需的属性。

我们举个例子帮助理解。假如现在有这样一个需求，工程在运行过程中用到的某个设置(例如VAR)是从系统环境变量中获取的，而如果用户没有在系统环境变量中配置这个参数，那么工程可能不会工作。这一要求可能有各种各样的解决办法，当然，在Spring中可以这样做，可以直接修改Spring的源码，例如修改`ClassPathXmlApplicationContext`。当然，最好的办法还是对源码进行扩展，我们可以自定义类：

```
public class MyClassPathXmlApplicationContext extends ClassPathXmlApplicationContext {
    public MyClassPathXmlApplicationContext(String... configLocations) {
        super(configLocations);
    }

    @Override
    protected void initPropertySources() {
        // 添加验证要求，VAR属性是必需的
        getEnvironment().setRequiredProperties("VAR");
    }
    
}
```

我们自定义了继承自`ClassPathXMLApplicationContext`的`MyClassPathXMLApplicationContext`，并重写了`initPropertySources`方法，在方法中添加了我们的个性化需求，那么在验证的时候也就是程序走到`getEnvironment().validateRequiredProperties()`的时候，如果系统并没有检测到对应的VAR环境变量，那么将抛出异常。

## 4. 加载BeanFactory

`obtainFreshBeanFactory`方法从字面上了解是获取`BeanFactory`。此方法正是实现`BeanFactory`的地方，也就是经过这个函数之后`ApplicatinContext`已经拥有了`BeanFactory`的全部功能。

```
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
   // 初始化BeanFactory，并进行xml文件读取，并将得到的BeanFactory记录在当前实体的属性中
   refreshBeanFactory();
   // 获取刚刚创建好的BeanFactory并返回
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   if (logger.isDebugEnabled()) {
      logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);
   }
   return beanFactory;
}

protected final void refreshBeanFactory() throws BeansException {
   // 如果已经有BeanFactory，则卸载它
   // 一般在容器启动后，手动调用refresh()方法才会执行这一步
   if (hasBeanFactory()) {
      destroyBeans();
      closeBeanFactory();
   }
   try {
      // 创建一个BeanFactory
      DefaultListableBeanFactory beanFactory = createBeanFactory();
      // 设置序列化id
      beanFactory.setSerializationId(getId());
      // 定制化BeanFactory
      customizeBeanFactory(beanFactory);
      // 加载bean定义
      loadBeanDefinitions(beanFactory);
      // 设置全局属性
      synchronized (this.beanFactoryMonitor) {
         this.beanFactory = beanFactory;
      }
   }
   catch (IOException ex) {
      throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
   }
}
```

我们详细介绍上面的每个步骤：

1. 创建DefaultListableBeanFactory
在介绍`BeanFactory`的时候，声明方式为`BeanFactory bf=new XmlBeanFactory("*.xml")`，其中的`XmlBeanFactory`继承自`DefaultListableBeanFactory`，并提供了`XmlBeanDefinitionReader`类型的reader属性，也就是说`DefaultListableBeanFactory`是容器的基础，必须要首先实例化
2. 指定序列化id
3. 定制BeanFactory
4. 加载bean定义
5. 使用全局变量记录BeanFactory的实例
因为`DefaultListableBeanFactory`类型的变量beanFactory是函数内的局部变量，所以要使用全局变量记录解析结果。

### 4.1. 定制BeanFactory

```
protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {
   // 是否允许覆盖同名称的不同定义的bean
   if (this.allowBeanDefinitionOverriding != null) {
      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
   }
   // 是否允许循环引用
   if (this.allowCircularReferences != null) {
      beanFactory.setAllowCircularReferences(this.allowCircularReferences);
   }
}
```

这里的两个设置只是判断了是否为空，如果不为空则对`BeanFactory`进行设置。

```
public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) {
   this.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;
}

public void setAllowCircularReferences(boolean allowCircularReferences) {
   this.allowCircularReferences = allowCircularReferences;
}

private Boolean allowBeanDefinitionOverriding;
private boolean allowCircularReferences = true;
```

`allowBeanDefinitionOverriding`默认为false，`allowCircularReferences`默认为true，这两个属性可使用setter方法进行设置：

```
ApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");
((ClassPathXmlApplicationContext) context).setAllowCircularReferences(false);
((ClassPathXmlApplicationContext) context).setAllowBeanDefinitionOverriding(true);
```

相信大家已经对这两个属性有了一定的了解，或者可以回到前面的章节进行再一次查看。

### 4.2. 加载BeanDefinition

除了对`DefaultListableBeanFactory`进行初始化，还需要`XmlBeanDefinitionReader`来读取xml文件。

```
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
   // Create a new XmlBeanDefinitionReader for the given BeanFactory.
   // 为BeanFactory创建一个XML读取器
   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

   // Configure the bean definition reader with this context's
   // resource loading environment.
   // 配置XML读取器
   beanDefinitionReader.setEnvironment(this.getEnvironment());
   beanDefinitionReader.setResourceLoader(this);
   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

   // Allow a subclass to provide custom initialization of the reader,
   // then proceed with actually loading the bean definitions.
   // 留待子类拓展
   initBeanDefinitionReader(beanDefinitionReader);
   // 加载bean定义
   loadBeanDefinitions(beanDefinitionReader);
}
```

初始化这个XML读取器，子类可以拓展这个默认实现，比如关闭xml验证或者使用一个不同的`XmlBeanDefinitionParser`。
```
protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) {
   // validating = true;
   reader.setValidating(this.validating);
}
```

```
protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
   // 获取XML配置文件资源
   Resource[] configResources = getConfigResources();
   if (configResources != null) {
      reader.loadBeanDefinitions(configResources);
   }
   // 获取XML配置文件路径，在ClassPathXmlApplicationContext构造方法的    
   // setConfigLocations(configLocations);中设置
   String[] configLocations = getConfigLocations();
   if (configLocations != null) {
      // 加载bean定义
      reader.loadBeanDefinitions(configLocations);
   }
}
```
```
public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
   Assert.notNull(locations, "Location array must not be null");
   int counter = 0;
   // 分别加载每一个配置文件
   for (String location : locations) {
      counter += loadBeanDefinitions(location);
   }
   return counter;
}

public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
   return loadBeanDefinitions(location, null);
}

public int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {
   ResourceLoader resourceLoader = getResourceLoader();
   if (resourceLoader == null) {
      throw new BeanDefinitionStoreException(
            "Cannot import bean definitions from location [" + location + "]: no ResourceLoader available");
   }

   // 解析以classpath*开头的路径
   if (resourceLoader instanceof ResourcePatternResolver) {
      // Resource pattern matching available.
      try {
         // 此时可能会找到多个符合条件的配置文件
         Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
         // 对每一个都进行解析加载
         int loadCount = loadBeanDefinitions(resources);
         if (actualResources != null) {
            for (Resource resource : resources) {
               actualResources.add(resource);
            }
         }
         if (logger.isDebugEnabled()) {
            logger.debug("Loaded " + loadCount + " bean definitions from location pattern [" + location + "]");
         }
         return loadCount;
      }
      catch (IOException ex) {
         throw new BeanDefinitionStoreException(
               "Could not resolve bean definition resource pattern [" + location + "]", ex);
      }
   }
   // 如果resourceLoader不是ResourcePatternResolver，那么只能解析一个文件
   else {
      // Can only load single resources by absolute URL.
      Resource resource = resourceLoader.getResource(location);
      int loadCount = loadBeanDefinitions(resource);
      if (actualResources != null) {
         actualResources.add(resource);
      }
      if (logger.isDebugEnabled()) {
         logger.debug("Loaded " + loadCount + " bean definitions from location [" + location + "]");
      }
      return loadCount;
   }
}

// 对应ResourcePatternResolver下的多文件解析
public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {
   Assert.notNull(resources, "Resource array must not be null");
   int counter = 0;
   for (Resource resource : resources) {
      counter += loadBeanDefinitions(resource);
   }
   return counter;
}

// 此时与前面XmlBeanFactory中介绍的配置文件加载已经一样了
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
   return loadBeanDefinitions(new EncodedResource(resource));
}
```

使用`XmlBeanDefinitionReader`的`loadBeanDefinitions`方法进行配置文件的加载注册我们在前面已经详细的介绍了。经过此步骤，`BeanFactory`已经包含了所有解析好的配置。

关于`ResourcePatternResolver`的判定，下面做一点解释：
```
// 这一句代码在XmlBeanDefinitionReader类中，而此类继承自AbstractBeanDefinitionReader
if (resourceLoader instanceof ResourcePatternResolver) 

// 我们回头看一下refreshBeanFactory()中的createBeanFactory()
// 它返回了一个普通的DefaultListableBeanFactory
protected DefaultListableBeanFactory createBeanFactory() {
   return new DefaultListableBeanFactory(getInternalParentBeanFactory());
}

// 之后在创建XmlBeanDefinitionReader时使用了这个DefaultListableBeanFactory
XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

// XmlBeanDefinitionReader构造的过程全部委托给了父类AbstractBeanDefinitionReader
public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {
   super(registry);
}

protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {
   Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
   this.registry = registry;

   // Determine ResourceLoader to use.
   // 注意此处就是classLoader的初始化，由于DefaultListableBeanFactory没有实现ResourceLoader接口
   // 所以在else中使用PathMatchingResourcePatternResolver作为classLoader
   if (this.registry instanceof ResourceLoader) {
      this.resourceLoader = (ResourceLoader) this.registry;
   }
   else {
      this.resourceLoader = new PathMatchingResourcePatternResolver();
   }

   // Inherit Environment if possible
   if (this.registry instanceof EnvironmentCapable) {
      this.environment = ((EnvironmentCapable) this.registry).getEnvironment();
   }
   else {
      this.environment = new StandardEnvironment();
   }
}

// 这就是PathMatchingResourcePatternResolver类的定义，它实现了ResourcePatternResolver接口
// 所以回到最前面，解析文件路径时是默认支持使用classpath*的
public class PathMatchingResourcePatternResolver implements ResourcePatternResolver
```

## 5. 功能扩展

在进入函数`prepareBeanFactory`前，Spring已经完成了对配置的解析，而`ApplicatinContext`在功能上的拓展也由此展开。

```
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   // 使用Spring自己的类加载器加载bean
   // 一般默认使用的线程上下文类加载器，此类加载器可以逆向类加载器的双亲委派模型
   // 考虑下面的场景：有多个应用部署到Tomcat中，它们都使用了Spring，为了节省内存，让Spring库成为一个公共库，
   // 此时Spring库会由Tomcat的顶层类加载器加载，而应用中的类则使用下层的类加载器加载
   // 当Spring加载容器中的bean时，由于双亲委派原则，应用类不在上层类加载器的搜索范围内，导致无法加载，
   // 此时使用线程上下文类加载器就可以逆向双亲委派原则，让上层类加载器请求下层类加载器加载类
   beanFactory.setBeanClassLoader(getClassLoader());
   // 设置SpEL的解析器
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   // 为beanFactory增加了一个默认的propertyEditor，主要是对bean的属性值进行类型转换
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

   // Configure the bean factory with context callbacks.
   // 注册后置处理器，针对实现*Aware接口的bean进行自动注入
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   // 设置几个忽略自动装配的接口
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   // 设置几个自动装配的特殊规则
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);

   // Register early post-processor for detecting inner beans as ApplicationListeners.
   // 注册后置处理器，解析ApplicationListener监听器类型的bean
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   // 增加对AspectJ的支持
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }

   // Register default environment beans.
   // 注册默认的Environment bean
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
```

上面函数中主要进行了几个方面的拓展
a. 增加对SpEL语言的支持
b. 增加对属性编辑器的支持
c. 增加对一些内置类，比如EnvironmentAware，MessageSourceAware的信息注入
d. 设置了依赖功能可忽略的接口
e. 注册一些固定依赖的属性
f. 增加对AspectJ的支持（后面具体讲解）
g. 将相关环境变量及属性注册以单例模式注册

### 5.1. 增加对SpEL语言的支持

Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，能在运行时构建复杂表达式，存取对象图属性，对象方法调用等，并且能与spring功能完美整合，比如能用来配置bean定义。

SpEL使用`#{...}`作为定界符，所有在大括号中的字符都被认为是SpEL，使用格式如下：

```
<bean id=”aa” class=”xxx.xxx.class” />
<bean>
    <property name=”instrument” value=”#{aa}” />
</bean>
```
相当于
```
<bean id=”aa” class=”xxx.xxx.class” />
<bean>
    <property name=”instrument” ref=”aa” />
</bean>
```
当然，上面只是举了最简单的使用方式，SpEL功能非常强大，使用好可以大大提高开发效率。

在源码中通过代码`beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));`注册语言解释器，就可以对SpEL进行解析了，那么注册后spring又是在什么时候调用这个解析器进行解析的呢？

之前我们讲解过spring在bean进行初始化的时候会有属性填充的一步，而在这一步中spring会调用`applyPropertyValues`函数来完成功能。就在这个函数中，会通过构造`BeanDefinitionValueResolver`的`valueResolver`来进行属性值的解析。同时也是在这个步骤中一般通过`evaluateBeanDefinitionString`方法完成SpEL的解析。

```
protected Object evaluateBeanDefinitionString(String value, BeanDefinition beanDefinition) {
   if (this.beanExpressionResolver == null) {
      return value;
   }
   Scope scope = (beanDefinition != null ? getRegisteredScope(beanDefinition.getScope()) : null);
   return this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));
}
```

### 5.2. 增加属性注册编辑器

在spring DI注入的时候可以把普通属性注入进来，但是像`Date`类型就无法被识别。

```
public class UserManager {
    private Date date;

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    @Override
    public String toString() {
        return "dateValue:" + date;
    }
}

<bean id="userManager" class="common.UserManager" >
    <property name="date" value="2013-03-15" />
</bean>

@Test
public void testDate() {
    BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("test4.xml"));
    UserManager manager = beanFactory.getBean("userManager", UserManager.class);
    System.out.println(manager);
}
```

如果直接这样使用，程序会报异常，类型转换不成功。因为date属性是`Date`类型的，而在xml中配置的是String类型的，所以会报异常。

Spring针对此问题提供了两种解决方法。

1. 使用自定义属性编辑器
a. 编写自定义属性编辑器
```
public class DatePropertyEditor extends PropertyEditorSupport {
    private String format = "yyyy-MM-dd";

    public String getFormat() {
        return format;
    }

    public void setFormat(String format) {
        this.format = format;
    }

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        SimpleDateFormat dateFormat = new SimpleDateFormat(format);
        try {
            Date d = dateFormat.parse(text);
            setValue(d);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
}
```
b. 将自定义属性编辑器注册到Spring中
```
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="customEditors">
        <map>
            <entry key="java.util.Date" value="support.DatePropertyEditor" />
        </map>
    </property>
</bean>
```

在Spring在注入bean属性时一旦遇到了`Date`类型的属性就会自动调用自定义的`DatePropertyEditor`解析器进行解析，并用解析结果代替配置属性进行注入。

2. 注册Spring中自带的属性编辑器`CustomDateEditor`
a. 定义属性编辑器
```
public class DatePropertyEditorRegistrar implements PropertyEditorRegistrar {
    @Override
    public void registerCustomEditors(PropertyEditorRegistry registry) {
        registry.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true));
    }
}
```
b. 注册到spring中
```
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="propertyEditorRegistrars">
        <list>
            <bean class="support.DatePropertyEditorRegistrar" />
        </list>
    </property>
</bean>
```

通过此办法可以获得与第一种方法同样的效果。

我们了解了自定义属性编辑器的使用，但是这似乎与我们此时讲的`beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()))`并无联系，因为在注册自定义属性编辑器的时候使用的是`PropertyEditorRegistrar`的`registerCustomEditors`方法，而在这里使用的是`DefaultListableBeanFactory`的`addPropertyEditorRegistrar`方法。我们不妨深入`ResourceEditorRegistrar`的内部实现，在`ResourceEditorRegistrar`中，我们最关心的方法是`registerCustomEditors`。

```
public void registerCustomEditors(PropertyEditorRegistry registry) {
   ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
   doRegisterEditor(registry, Resource.class, baseEditor);
   doRegisterEditor(registry, ContextResource.class, baseEditor);
   doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
   doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
   doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
   if (pathClass != null) {
      doRegisterEditor(registry, pathClass, new PathEditor(baseEditor));
   }
   doRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));
   doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

   ClassLoader classLoader = this.resourceLoader.getClassLoader();
   doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
   doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
   doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

   if (this.resourceLoader instanceof ResourcePatternResolver) {
      doRegisterEditor(registry, Resource[].class,
            new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
   }
}

private void doRegisterEditor(PropertyEditorRegistry registry, Class<?> requiredType, PropertyEditor editor) {
   if (registry instanceof PropertyEditorRegistrySupport) {
      ((PropertyEditorRegistrySupport) registry).overrideDefaultEditor(requiredType, editor);
   }
   else {
      registry.registerCustomEditor(requiredType, editor);
   }
}
```

在`doRegisterEditor`函数中，我们可以看到在之前提到的自定义属性使用的关键代码：`registry.registerCustomEditor`，回过头看`ResourceEditorRegistrar`类`registerCustomEditors`方法的核心功能，其实无非是注册了一系列的常用类型的属性编辑器。例如，代码`doRegisterEditor(registry, Class.class, new ClassEditor(classLoader))`实现的功能就是注册Class类对应的属性编辑器，那么，注册后，一旦某个实体bean中存在一些Class类型的属性，那么spring就会调用`ClassEditor`将配置中的String类型转换为Class类型并进行赋值。

分析到这里，我们不禁有个疑问，虽说`ResourceEditorRegistrar`类的方法`registerCustomEditors`实现了批量注册的功能，但是`beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()))`仅仅是注册了实例，却没有调用`ResourceEditorRegistrar`类的方法`registerCustomEditors`进行注册，那么是什么时候开始进行注册的呢？进一步查看`ResourceEditorRegistrar`类的方法`registerCustomEditors`的调用层次。

![](https://upload-images.jianshu.io/upload_images/13068256-deba54dfdc2c73f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

发现在`AbstractBeanFactory`类的`registerCustomEditors`方法中被调用过，继续查看调用层次结构：

![](https://upload-images.jianshu.io/upload_images/13068256-10db5e4cd545c60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

有一个方法是我们熟悉的，就是`initBeanWrapper`方法，这是在bean初始化时使用的一个方法，之前已经花费了大量的篇幅进行介绍。到此，逻辑已经明了，在bean的初始化之后会调用方法进行批量的通用属性编辑器注册。注册后，在属性填充的环节就可以直接让spring使用这些编辑器进行属性的解析了。

这里有必要强调下，spring用于封装bean的是`BeanWrapper`类型，它有间接继承了`PropertyEditorRegistry`类型，对于`BeanWrapper`在spring中默认实现为`BeanWrapperImpl`，而`BeanWrapperImpl`除了实现`BeanWrapper`接口外还继承了`PropertyEditorRegistrySupport`，在`PropertyEditorRegistrySupport`中有这样的一个方法：

```
private void createDefaultEditors() {
   this.defaultEditors = new HashMap<Class<?>, PropertyEditor>(64);

   // Simple editors, without parameterization capabilities.
   // The JDK does not contain a default editor for any of these target types.
   this.defaultEditors.put(Charset.class, new CharsetEditor());
   this.defaultEditors.put(Class.class, new ClassEditor());
   this.defaultEditors.put(Class[].class, new ClassArrayEditor());
   this.defaultEditors.put(Currency.class, new CurrencyEditor());
   this.defaultEditors.put(File.class, new FileEditor());
   this.defaultEditors.put(InputStream.class, new InputStreamEditor());
   this.defaultEditors.put(InputSource.class, new InputSourceEditor());
   this.defaultEditors.put(Locale.class, new LocaleEditor());
   if (pathClass != null) {
      this.defaultEditors.put(pathClass, new PathEditor());
   }
   this.defaultEditors.put(Pattern.class, new PatternEditor());
   this.defaultEditors.put(Properties.class, new PropertiesEditor());
   this.defaultEditors.put(Reader.class, new ReaderEditor());
   this.defaultEditors.put(Resource[].class, new ResourceArrayPropertyEditor());
   this.defaultEditors.put(TimeZone.class, new TimeZoneEditor());
   this.defaultEditors.put(URI.class, new URIEditor());
   this.defaultEditors.put(URL.class, new URLEditor());
   this.defaultEditors.put(UUID.class, new UUIDEditor());
   if (zoneIdClass != null) {
      this.defaultEditors.put(zoneIdClass, new ZoneIdEditor());
   }

   // Default instances of collection editors.
   // Can be overridden by registering custom instances of those as custom editors.
   this.defaultEditors.put(Collection.class, new CustomCollectionEditor(Collection.class));
   this.defaultEditors.put(Set.class, new CustomCollectionEditor(Set.class));
   this.defaultEditors.put(SortedSet.class, new CustomCollectionEditor(SortedSet.class));
   this.defaultEditors.put(List.class, new CustomCollectionEditor(List.class));
   this.defaultEditors.put(SortedMap.class, new CustomMapEditor(SortedMap.class));

   // Default editors for primitive arrays.
   this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());
   this.defaultEditors.put(char[].class, new CharArrayPropertyEditor());

   // The JDK does not contain a default editor for char!
   this.defaultEditors.put(char.class, new CharacterEditor(false));
   this.defaultEditors.put(Character.class, new CharacterEditor(true));

   // Spring's CustomBooleanEditor accepts more flag values than the JDK's default editor.
   this.defaultEditors.put(boolean.class, new CustomBooleanEditor(false));
   this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(true));

   // The JDK does not contain default editors for number wrapper types!
   // Override JDK primitive number editors with our own CustomNumberEditor.
   this.defaultEditors.put(byte.class, new CustomNumberEditor(Byte.class, false));
   this.defaultEditors.put(Byte.class, new CustomNumberEditor(Byte.class, true));
   this.defaultEditors.put(short.class, new CustomNumberEditor(Short.class, false));
   this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, true));
   this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));
   this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));
   this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));
   this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));
   this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));
   this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));
   this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));
   this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));
   this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));
   this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));

   // Only register config value editors if explicitly requested.
   if (this.configValueEditorsActive) {
      StringArrayPropertyEditor sae = new StringArrayPropertyEditor();
      this.defaultEditors.put(String[].class, sae);
      this.defaultEditors.put(short[].class, sae);
      this.defaultEditors.put(int[].class, sae);
      this.defaultEditors.put(long[].class, sae);
   }
}
```

通过这个方法我们已经知道了在spring中定义了一系列常用的属性编辑器使我们可以方便的进行配置。如果我们定义的bean中的某个属性的类型不在上面的常用配置中的话，才需要我们进行个性化的属性编辑器的注册。

### 5.3. 增加ApplicationContextAwareProcessor处理器

在了解属性编辑器之后，接下来我们继续对`prepareBeanFactory`方法的主线进行跟踪。对于`beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this))`其实主要目的就是注册个`BeanPostProcessor`，而真正的逻辑还是`ApplicationContextAwareProcessor`中。

`ApplicationContextAwareProcessor`实现`BeanPostProcessor`接口，我们回顾下之前讲过的内容，在bean实例化的时候，也就是spring激活bean的init-method的前后，会调用`BeanPostProcessor`的`postProcessAfterInitialiaztion`方法和`postProcessBeforeInitialiaztion`方法。同样，对于`ApplicationContextAwareProcessor`我们也关心这两个方法。

```
public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
   AccessControlContext acc = null;

   if (System.getSecurityManager() != null &&
         (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
               bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
               bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
      acc = this.applicationContext.getBeanFactory().getAccessControlContext();
   }

   if (acc != null) {
      AccessController.doPrivileged(new PrivilegedAction<Object>() {
         @Override
         public Object run() {
            invokeAwareInterfaces(bean);
            return null;
         }
      }, acc);
   }
   else {
      invokeAwareInterfaces(bean);
   }

   return bean;
}

private void invokeAwareInterfaces(Object bean) {
   if (bean instanceof Aware) {
      if (bean instanceof EnvironmentAware) {
         ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
      }
      if (bean instanceof EmbeddedValueResolverAware) {
         ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
      }
      if (bean instanceof ResourceLoaderAware) {
         ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
      }
      if (bean instanceof ApplicationEventPublisherAware) {
         ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
      }
      if (bean instanceof MessageSourceAware) {
         ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
      }
      if (bean instanceof ApplicationContextAware) {
         ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
      }
   }
}

public Object postProcessAfterInitialization(Object bean, String beanName) {
   return bean;
}
```

`postProcessAfterInitialiaztion`方法为默认实现，并没有做什么处理。

`postProcessBeforeInitialiaztion`方法中调用了`invokeAwareInterfaces`。在前面`XmlBeanFactory`分析中，我们也见到过此方法，不过相对于`XmlBeanFactory`中的`invokeAwareInterfaces`方法，此方法中增加了更多的`Aware`接口，而正是因为`ApplicationContext`的拓展，所以才产生了这些接口。

### 5.4. 设置忽略依赖

当spring将`ApplicationContextAwareProcessor`注册后，那么在`invokeAwareInterfaces`方法中间接调用的`Aware`类就已经不是普通的bean了，那么就需要在spring做bean的依赖注入的时候忽略他们。而`ignoreDependencyInterface`的作用正是在此。

```
beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

public void ignoreDependencyType(Class<?> type) {
   this.ignoredDependencyTypes.add(type);
}

protected boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {
   return (AutowireUtils.isExcludedFromDependencyCheck(pd) ||
         this.ignoredDependencyTypes.contains(pd.getPropertyType()) ||
         AutowireUtils.isSetterDefinedInInterface(pd, this.ignoredDependencyInterfaces));
}

protected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {
   Set<String> result = new TreeSet<String>();
   PropertyValues pvs = mbd.getPropertyValues();
   PropertyDescriptor[] pds = bw.getPropertyDescriptors();
   for (PropertyDescriptor pd : pds) {
      if (pd.getWriteMethod() != null && !isExcludedFromDependencyCheck(pd) && !pvs.contains(pd.getName()) &&
            !BeanUtils.isSimpleProperty(pd.getPropertyType())) {
         result.add(pd.getName());
      }
   }
   return StringUtils.toStringArray(result);
}
```

最后一个方法就是在进行属性自动注入时，查找满足条件的bean的方法。

### 5.5. 注册依赖

spring中有了忽略依赖的功能，当然也会必不可少的会有注册依赖的功能。

```
beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
beanFactory.registerResolvableDependency(ResourceLoader.class, this);
beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
beanFactory.registerResolvableDependency(ApplicationContext.class, this);
```

当注册了依赖解析后，例如当注册了对`BeanFactory.class`的解析依赖后，当bean的属性注入的时候，一旦检测到属性为`BeanFactory`类型便会将beanFactory注入进去。

```
public void registerResolvableDependency(Class<?> dependencyType, Object autowiredValue) {
   Assert.notNull(dependencyType, "Dependency type must not be null");
   if (autowiredValue != null) {
      if (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) {
         throw new IllegalArgumentException("Value [" + autowiredValue +
               "] does not implement specified dependency type [" + dependencyType.getName() + "]");
      }
      this.resolvableDependencies.put(dependencyType, autowiredValue);
   }
}

protected Map<String, Object> findAutowireCandidates(
      String beanName, Class<?> requiredType, DependencyDescriptor descriptor) {

   String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
         this, requiredType, true, descriptor.isEager());
   Map<String, Object> result = new LinkedHashMap<String, Object>(candidateNames.length);
   for (Class<?> autowiringType : this.resolvableDependencies.keySet()) {
      if (autowiringType.isAssignableFrom(requiredType)) {
         Object autowiringValue = this.resolvableDependencies.get(autowiringType);
         autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);
         if (requiredType.isInstance(autowiringValue)) {
            result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);
            break;
         }
      }
   }
   for (String candidate : candidateNames) {
      if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {
         addCandidateEntry(result, candidate, descriptor, requiredType);
      }
   }
   if (result.isEmpty() && !indicatesMultipleBeans(requiredType)) {
      // Consider fallback matches if the first pass failed to find anything...
      DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();
      for (String candidate : candidateNames) {
         if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, fallbackDescriptor)) {
            addCandidateEntry(result, candidate, descriptor, requiredType);
         }
      }
      if (result.isEmpty()) {
         // Consider self references as a final pass...
         // but in the case of a dependency collection, not the very same bean itself.
         for (String candidate : candidateNames) {
            if (isSelfReference(beanName, candidate) &&
                  (!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) &&
                  isAutowireCandidate(candidate, fallbackDescriptor)) {
               addCandidateEntry(result, candidate, descriptor, requiredType);
            }
         }
      }
   }
   return result;
}

protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {
   Class<?> requiredType = descriptor.getDependencyType();
   String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);
   if (primaryCandidate != null) {
      return primaryCandidate;
   }
   String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);
   if (priorityCandidate != null) {
      return priorityCandidate;
   }
   // Fallback
   for (Map.Entry<String, Object> entry : candidates.entrySet()) {
      String candidateName = entry.getKey();
      Object beanInstance = entry.getValue();
      if ((beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) ||
            matchesBeanName(candidateName, descriptor.getDependencyName())) {
         return candidateName;
      }
   }
   return null;
}
```

后两个方法都是在进行bean的属性注入时调用的方法。

### 5.6. 查明ApplicationListener

```
beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
```

`ApplicationListenerDetector`的作用是查找类型为`ApplicationListener`的bean，并将它注册到监听器集合中。关于监听器，查看[1.15.2. Standard and Custom Events](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-functionality-events)获得更多信息。

`ApplicationListenerDetector`实现了`BeanPostProcessor`接口，我们同样关注`postProcessAfterInitialiaztion`方法和`postProcessBeforeInitialiaztion`方法。

```
public Object postProcessBeforeInitialization(Object bean, String beanName) {
   return bean;
}

public Object postProcessAfterInitialization(Object bean, String beanName) {
   if (this.applicationContext != null && bean instanceof ApplicationListener) {
      // potentially not detected as a listener by getBeanNamesForType retrieval
      Boolean flag = this.singletonNames.get(beanName);
      if (Boolean.TRUE.equals(flag)) {
         // singleton bean (top-level or inner): register on the fly
         this.applicationContext.addApplicationListener((ApplicationListener<?>) bean);
      }
      // 监听器要求一定需要是单例
      else if (Boolean.FALSE.equals(flag)) {
         if (logger.isWarnEnabled() && !this.applicationContext.containsBean(beanName)) {
            // inner bean with other scope - can't reliably process events
            logger.warn("Inner bean '" + beanName + "' implements ApplicationListener interface " +
                  "but is not reachable for event multicasting by its containing ApplicationContext " +
                  "because it does not have singleton scope. Only top-level listener beans are allowed " +
                  "to be of non-singleton scope.");
         }
         this.singletonNames.remove(beanName);
      }
   }
   return bean;
}
```

在此方法中，如果配置文件中的bean为`ApplicationListener`类型的，就会将其增加到监听器中。而`singletonNames`的设置则是在`postProcessMergedBeanDefinition`方法中，`ApplicationListenerDetector`真正实现的是`MergedBeanDefinitionPostProcessor`，而此接口继承自`BeanPostProcessor`接口，回忆之前`getBean()`中后置处理器的应用，可以发现`MergedBeanDefinitionPostProcessor`接口中的方法在实例化过程中就已经调用了，而`BeanPostProcessor`中的方法在最后才调用，所以在对`singletonNames`进行检查时，它已经被初始化了。

```
public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
   if (this.applicationContext != null) {
      this.singletonNames.put(beanName, beanDefinition.isSingleton());
   }
}
```

`prepareBeanFactory`方法最后则是对AspectJ的支持，后续进行讲解。

## 6. BeanFactory的后处理

`BeanFactory`作为spring中容器功能的基础，用于存放所有已经加载的bean，为了保证程序的高可扩展性，spring针对`BeanFactory`做了大量的扩展，比如我们熟知的`BeanFactoryPostProcessor`就是在这里实现的。

```
// Invoke factory processors registered as beans in the context.
invokeBeanFactoryPostProcessors(beanFactory);

// Register bean processors that intercept bean creation.
registerBeanPostProcessors(beanFactory);
```

### 6.1. 激活注册的BeanFactoryPostProcessor

关于`BeanFactoryPostProcessor`，查看[1.8.2. Customizing Configuration Metadata with a BeanFactoryPostProcessor](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-factory-postprocessors)获取更多信息。

```
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}

public static void invokeBeanFactoryPostProcessors(
      ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

   // Invoke BeanDefinitionRegistryPostProcessors first, if any.
   Set<String> processedBeans = new HashSet<String>();

   // 对BeanDefinitionRegistry类型的处理
   if (beanFactory instanceof BeanDefinitionRegistry) {
      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
      // 普通BeanFactoryPostProcessor后置处理器
      List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();
      // BeanDefinitionRegistryPostProcessor后置处理器
      List<BeanDefinitionRegistryPostProcessor> registryProcessors = new LinkedList<BeanDefinitionRegistryPostProcessor>();
      // 硬解码注册的后处理器
      for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
         if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
            BeanDefinitionRegistryPostProcessor registryProcessor =
                  (BeanDefinitionRegistryPostProcessor) postProcessor;
            // 对于BeanDefinitionRegistryPostProcessor类型，在BeanFactoryPostProcessor的基础上
            // 还有自己定义的方法，需要先调用 
            registryProcessor.postProcessBeanDefinitionRegistry(registry);
            registryProcessors.add(registryProcessor);
         }
         else {
            regularPostProcessors.add(postProcessor);
         }
      }

      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the bean factory post-processors apply to them!
      // Separate between BeanDefinitionRegistryPostProcessors that implement
      // PriorityOrdered, Ordered, and the rest.
      List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();

      // 硬编码注册的BeanFactory后置处理器优先注册，然后注册XML文件中配置的BeanFactory后置处理器

      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
      // 对于实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor
      String[] postProcessorNames =
            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      // 对其进行排序
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      // 调用自定义的方法postProcessBeanDefinitionRegistry
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();

      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
      // 然后对实现了Ordered接口的BeanDefinitionRegistryPostProcessors进行注册
      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
      for (String ppName : postProcessorNames) {
         if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
         }
      }
      sortPostProcessors(currentRegistryProcessors, beanFactory);
      registryProcessors.addAll(currentRegistryProcessors);
      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
      currentRegistryProcessors.clear();

      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
      // 最后，注册所有其他的BeanDefinitionRegistryPostProcessors
      boolean reiterate = true;
      while (reiterate) {
         reiterate = false;
         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
         for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName)) {
               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
               processedBeans.add(ppName);
               reiterate = true;
            }
         }
         sortPostProcessors(currentRegistryProcessors, beanFactory);
         registryProcessors.addAll(currentRegistryProcessors);
         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
         currentRegistryProcessors.clear();
      }

      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
     // 处理了所有的BeanDefinitionRegistryPostProcessor的自定义方法后，调用BeanFactoryPostProcessor接口的postProcessBeanFactory方法
      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
   }

   else {
      // Invoke factory processors registered with the context instance.
      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
   }

   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let the bean factory post-processors apply to them!
   // 处理XML配置文件中的BeanFactoryPostProcessor，处理过程与BeanDefinitionRegistryPostProcessor相同
   String[] postProcessorNames =
         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
   List<String> orderedPostProcessorNames = new ArrayList<String>();
   List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
   for (String ppName : postProcessorNames) {
      // 跳过已经在前面注册的后置处理器
      if (processedBeans.contains(ppName)) {
         // skip - already processed in first phase above
      }
      // 分别处理实现了PriorityOrdered，Ordered接口的bean以及普通bean
      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }

   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
   List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
   for (String postProcessorName : orderedPostProcessorNames) {
      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

   // Finally, invoke all other BeanFactoryPostProcessors.
   List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
   for (String postProcessorName : nonOrderedPostProcessorNames) {
      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
   }
   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

   // Clear cached merged bean definitions since the post-processors might have
   // modified the original metadata, e.g. replacing placeholders in values...
   beanFactory.clearMetadataCache();
}
```

从上面的方法看出，对于`BeanFactoryPostProcessor`的处理分为两种情况进行，一个是对于`BeanDefinitionRegistry`类的特殊处理，另一种是对普通的`BeanFactoryPostProcessor`进行处理。而对于每种情况都需要考虑硬编码注入注册的后处理器和通过配置注入的后处理器。

a. 对BeanDefinitionRegistry的处理
首先处理硬编码注册的后处理器。此处理器通过如下形式增加。
```
public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor) {
   Assert.notNull(postProcessor, "BeanFactoryPostProcessor must not be null");
   this.beanFactoryPostProcessors.add(postProcessor);
}
```
其中对于`BeanDefinitionRegistryPostProcessor`类型的后处理器，它继承了`BeanFactoryPostProcessor`接口，不但有`BeanFactoryPostProcessor`的特性，同时还有自己定义的个性化方法，也需要在此调用。

然后读取配置文件中的`BeanDefinitionRegistryPostProcessor`类型的bean，对其按照PriorityOrdered，Ordered，普通类型进行分类，并且进行注册。

b. 如果beanFactory不是BeanDefinitionRegistry类型
则硬编码的后处理器都是普通的`BeanFactoryPostProcessor`类型。直接进行注册激活即可。

c. 普通的BeanFactoryPostProcessor类型处理
无论beanFactory是不是`BeanDefinitionRegistry`类型，硬编码的后处理器都已经处理完成了。同时`BeanDefinitionRegistryPostProcessor`类型的后处理器也已经在其中全部处理完成。接下来则是普通的`BeanFactoryPostProcessor`类型处理。
从配置文件中读取`BeanFactoryPostProcessor`类型的bean，同样对其进行分类然后各自激活，调用统一的`postProcessBeanFactory`方法。注意实现了排序接口的`BeanFactoryPostProcessor`会优先调用，然后才调用普通的`BeanFactoryPostProcessor`。

### 6.2. 注册BeanPostProcessor

上面提到`BeanFactoryPostProcessor`的调用，现在我们来探索`BeanPostProcessor`，但这里并不是调用，而是注册。真正的调用其实是在bean的实例化阶段进行的。这是一个很重要的步骤，也是很多功能`BeanFactory`不支持的重要原因。spring绝大多数功能都是通过后处理器的方式进行拓展的，这是spring框架的一个特性，但是`BeanFactory`中并没有实现后处理器的自动注册 ，所以在调用的时候如果没有进行手动注册其实是不能使用的。但是在`ApplicationContext`中增加了自动注册功能。

```
protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
}

public static void registerBeanPostProcessors(
      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

    // 读取XML配置文件中注册的BeanPostProcessor后置处理器
   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

   // Register BeanPostProcessorChecker that logs an info message when
   // a bean is created during BeanPostProcessor instantiation, i.e. when
   // a bean is not eligible for getting processed by all BeanPostProcessors.
   int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
   // 注册一个后置处理器，当BeanPostProcessor实例化的时候如果有bean被创建，
   // 记录日志信息
   beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

   // Separate between BeanPostProcessors that implement PriorityOrdered,
   // Ordered, and the rest.
   // 按PriorityOrdered，Ordered以及其他进行分类
   List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();
   List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();
   List<String> orderedPostProcessorNames = new ArrayList<String>();
   List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
   for (String ppName : postProcessorNames) {
      if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
         priorityOrderedPostProcessors.add(pp);
         if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
         }
      }
      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
         orderedPostProcessorNames.add(ppName);
      }
      else {
         nonOrderedPostProcessorNames.add(ppName);
      }
   }

   // First, register the BeanPostProcessors that implement PriorityOrdered.
   // 首先注册实现了PriorityOrdered接口的BeanPostProcessor
   // 注册过程很简单，调用BeanFactory的addBeanPostProcessor(BeanPostProcessor)方法即可
   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

   // Next, register the BeanPostProcessors that implement Ordered.
   // 然后，注册实现了Ordered接口的BeanPostProcessor
   List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();
   for (String ppName : orderedPostProcessorNames) {
      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
      orderedPostProcessors.add(pp);
      if (pp instanceof MergedBeanDefinitionPostProcessor) {
         internalPostProcessors.add(pp);
      }
   }
   sortPostProcessors(orderedPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, orderedPostProcessors);

   // Now, register all regular BeanPostProcessors.
   // 再注册所有常规的BeanPostProcessor
   List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();
   for (String ppName : nonOrderedPostProcessorNames) {
      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
      nonOrderedPostProcessors.add(pp);
      if (pp instanceof MergedBeanDefinitionPostProcessor) {
         internalPostProcessors.add(pp);
      }
   }
   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

   // Finally, re-register all internal BeanPostProcessors.
   // 最后注册所有实现MergedBeanDefinitionPostProcessor接口的后置处理器
   sortPostProcessors(internalPostProcessors, beanFactory);
   registerBeanPostProcessors(beanFactory, internalPostProcessors);

   // Re-register post-processor for detecting inner beans as ApplicationListeners,
   // moving it to the end of the processor chain (for picking up proxies etc).
   // 再次注册ApplicationListenerDetector后置处理器，将它置于处理器链的尾部
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}
```

配合源码以及注释，此方法中的逻辑相信很容易理解，我们做一下总结。

首先我们发现，对于`BeanPostProcessor`的处理和`BeanFactoryPostProcessor`的处理极为相似，但是似乎又有些不同的地方。对于`BeanFactoryPostProcessor`的处理要区分两种情况，一种是是硬编码形式的处理，另一种是通过配置文件方式的处理。而在`BeanPostProcessor`中只要考虑配置文件方式的处理。为什么如此呢？对于`BeanFactoryPostProcessor`的处理，不但要实现注册功能，还要实现对后处理器的激活操作；而`BeanPostProcessor`并不需要马上调用，所以不需要考虑通过硬编码注册的`BeanPostProcessor`。

### 6.3. 初始化消息资源

关于Spring国际化，查看1.15.1. Internationalization using MessageSource](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-functionality-messagesource)获取更多信息。

在`initMessageSource`中的方法主要功能是提取配置文件中定义的`messageSource`，并将其记录在spring的容器中。当然，如果用户未设置`messageSource`的话，spring中也提供了默认的配置`DelegatingMessageSource`。

```
protected void initMessageSource() {
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   // 检测是否有名为messageSource的bean
   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
      // Make MessageSource aware of parent MessageSource.
      // 如果使用了继承体系的MessageSource
      if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {
         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
         if (hms.getParentMessageSource() == null) {
            // Only set parent context as parent MessageSource if no parent MessageSource
            // registered already.
            hms.setParentMessageSource(getInternalParentMessageSource());
         }
      }
      if (logger.isDebugEnabled()) {
         logger.debug("Using MessageSource [" + this.messageSource + "]");
      }
   }
   // 如果用户没有自定义messageSource，那么使用默认的DelegatingMessageSource
   else {
      // Use empty MessageSource to be able to accept getMessage calls.
      DelegatingMessageSource dms = new DelegatingMessageSource();
      dms.setParentMessageSource(getInternalParentMessageSource());
      this.messageSource = dms;
      // 注册此bean
      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
      if (logger.isDebugEnabled()) {
         logger.debug("Unable to locate MessageSource with name '" + MESSAGE_SOURCE_BEAN_NAME +
               "': using default [" + this.messageSource + "]");
      }
   }
}
```

### 6.4. 初始化ApplicationEventMulticaster

关于事件广播，查看[1.15.2. Standard and Custom Events](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-functionality-events)获取更多信息。

```
protected void initApplicationEventMulticaster() {
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   // 如果用户指定了名为applicationEventMulticaster的bean
   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
      // 使用用户自定义的bean
      this.applicationEventMulticaster =
            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
      if (logger.isDebugEnabled()) {
         logger.debug("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
      }
   }
   // 否则，使用Spring默认的SimpleApplicationEventMulticaster
   else {
      this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
      if (logger.isDebugEnabled()) {
         logger.debug("Unable to locate ApplicationEventMulticaster with name '" +
               APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
               "': using default [" + this.applicationEventMulticaster + "]");
      }
   }
}
```

下面探究一下默认的`SimpleApplicationEventMulticaster`的内部实现。

```
@Override
public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
   ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
   // 对于所有的监听器
   for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
       // 如果存在线程池，则使用线程池来调用监听器，这样不会影响主线程的执行
      Executor executor = getTaskExecutor();
      if (executor != null) {
         executor.execute(new Runnable() {
            @Override
            public void run() {
               invokeListener(listener, event);
            }
         });
      }
      else {
         invokeListener(listener, event);
      }
   }
}

protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {
   ErrorHandler errorHandler = getErrorHandler();
   if (errorHandler != null) {
      try {
         // 真正调用监听器
         doInvokeListener(listener, event);
      }
      catch (Throwable err) {
         errorHandler.handleError(err);
      }
   }
   else {
      doInvokeListener(listener, event);
   }
}

private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
   try {
      // 调用监听器的onApplicationEvent方法
      listener.onApplicationEvent(event);
   }
   catch (ClassCastException ex) {
      String msg = ex.getMessage();
      if (msg == null || msg.startsWith(event.getClass().getName())) {
         // Possibly a lambda-defined listener which we could not resolve the generic event type for
         Log logger = LogFactory.getLog(getClass());
         if (logger.isDebugEnabled()) {
            logger.debug("Non-matching event type for listener: " + listener, ex);
         }
      }
      else {
         throw ex;
      }
   }
}
```

当产生spring事件的时候会默认使用`multicastEvent`来广播事件，遍历所有监听器，并使用监听器的`onApplicationEvent`方法来进行监听器的处理。对于每个监听器其实都可以获取到产生的事件，但是是否进行处理则由事件监听器来决定。

### 6.5. 注册监听器

之前在介绍spring的广播器时反复提到了事件监听器，那么在spring注册监听器的时候又做了哪些操作呢？

```
protected void registerListeners() {
   // Register statically specified listeners first.
   // 注册通过硬编码注册的监听器
   for (ApplicationListener<?> listener : getApplicationListeners()) {
      getApplicationEventMulticaster().addApplicationListener(listener);
   }

   // Do not initialize FactoryBeans here: We need to leave all regular beans
   // uninitialized to let post-processors apply to them!
   // 注册XML文件中配置的监听器
   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
   for (String listenerBeanName : listenerBeanNames) {
      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
   }

   // Publish early application events now that we finally have a multicaster...
   // 发布早期事件
   Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
   this.earlyApplicationEvents = null;
   if (earlyEventsToProcess != null) {
      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
         getApplicationEventMulticaster().multicastEvent(earlyEvent);
      }
   }
}
```

## 7. 初始化非延迟加载单例

完成`BeanFactory`的初始化工作，其中包含`ConversionService`的设置，配置冻结以及非延迟加载的bean的初始化工作。

```
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
   // Initialize conversion service for this context.
   // 初始化类型转换服务
   // 如果XML文件中存在名为conversionService的bean，那么使用它
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   }

   // Register a default embedded value resolver if no bean post-processor
   // (such as a PropertyPlaceholderConfigurer bean) registered any before:
   // at this point, primarily for resolution in annotation attribute values.
   // 如果没有类似PropertyPlaceholderConfigurer这样的bean被注册，注册一个默认的嵌入值解析器
   if (!beanFactory.hasEmbeddedValueResolver()) {
      beanFactory.addEmbeddedValueResolver(new StringValueResolver() {
         @Override
         public String resolveStringValue(String strVal) {
            return getEnvironment().resolvePlaceholders(strVal);
         }
      });
   }

   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
   // 初始化LoadTimeWeaverAware bean
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) {
      getBean(weaverAwareName);
   }

   // Stop using the temporary ClassLoader for type matching.
   // 停止使用临时的类加载器
   beanFactory.setTempClassLoader(null);

   // Allow for caching all bean definition metadata, not expecting further changes.
   // 冻结配置文件
   beanFactory.freezeConfiguration();

   // Instantiate all remaining (non-lazy-init) singletons.
   // 提前实例化单例
   beanFactory.preInstantiateSingletons();
}
```

首先我们了解下ConversionService类的作用。

1. ConversionService的设置

之前我们提到过使用自定义类型转换器从String转换到Date的方式，那么在Spring中还提供了另一种转换方式：使用`Converter`。同样，我们使用一个简单的示例来了解一下使用方式。

```
public class String2DateConverter implements Converter<String, Date> {
    @Override
    public Date convert(String source) {
        try {
            SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            return format.parse(source);
        } catch (ParseException e) {
            e.printStackTrace();
            return null;
        }
    }
}

<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <list>
            <bean class="support.String2DateConverter" />
        </list>
    </property>
</bean>

@Test
public void testConverter() {
    ApplicationContext context = new ClassPathXmlApplicationContext("test3.xml");
    ConversionService service = context.getBean("conversionService", ConversionService.class);
    Date date = service.convert("2018-8-13 10:01:15", Date.class);
    System.out.println(date);
}
```

测试方法显得较为笨拙，不过此转换器会在mvc中自动调用对参数进行转换。

2. 冻结配置
因为此时bean配置元数据已经不会有任何的改变了，所以冻结配置。
```
public void freezeConfiguration() {
   this.configurationFrozen = true;
   this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);
}
```

3. 初始化非延迟加载的单例
`ApplicationContext`实现的默认行为就是在启动时将所有的单例bean提前进行实例化。提前实例化意味着作为初始化过程的一部分，`ApplicationContext`会创建并配置所有的单例bean。通常情况下这是一件好事，因为这样在配置中的任何错误就会被立刻发现。

```
public void preInstantiateSingletons() throws BeansException {
   if (this.logger.isDebugEnabled()) {
      this.logger.debug("Pre-instantiating singletons in " + this);
   }

   // Iterate over a copy to allow for init methods which in turn register new bean definitions.
   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
   List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);

   // Trigger initialization of all non-lazy singleton beans...
   for (String beanName : beanNames) {
      // 获取bean的元数据
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      // 如果此bean不是抽象bean并且是一个单例并且没有指定lazy-init="true"
      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
         // 如果是一个FactoryBean
         if (isFactoryBean(beanName)) {
            // 调用getBean实例化这个bean
            final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);
            boolean isEagerInit;
            if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
               // 如果这个FactoryBean实现了SmartFactoryBean接口，并且isEagerInit()方法返回true，
               // 那么还会提前实例化这个FactoryBean创建的对象
               isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
                  @Override
                  public Boolean run() {
                     return ((SmartFactoryBean<?>) factory).isEagerInit();
                  }
               }, getAccessControlContext());
            }
            else {
               isEagerInit = (factory instanceof SmartFactoryBean &&
                     ((SmartFactoryBean<?>) factory).isEagerInit());
            }
            if (isEagerInit) {
               getBean(beanName);
            }
         }
         else {
            getBean(beanName);
         }
      }
   }

   // Trigger post-initialization callback for all applicable beans...
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      // 如果单例bean实现了SmartInitializingSingleton接口，调用其afterSingletonsInstantiated()方法
      if (singletonInstance instanceof SmartInitializingSingleton) {
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged(new PrivilegedAction<Object>() {
               @Override
               public Object run() {
                  smartSingleton.afterSingletonsInstantiated();
                  return null;
               }
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
```

## 8. finishRefresh

在Spring中还提供了`Lifecycle`接口，`Lifecycle`中包含了`start/stop`方法，实现此接口后Spring中会保证在启动的时候调用其start方法开始生命周期，并在spring结束的时候调用stop方法来结束声明周期，通常用来配置配置后台程序，在启动后一直运行。关于`Lifecycle`接口，查看[1.6.1. Lifecycle Callbacks](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle)获取更多信息。

```
protected void finishRefresh() {
   // Initialize lifecycle processor for this context.
   initLifecycleProcessor();

   // Propagate refresh to lifecycle processor first.
   getLifecycleProcessor().onRefresh();

   // Publish the final event.
   publishEvent(new ContextRefreshedEvent(this));

   // Participate in LiveBeansView MBean, if active.
   LiveBeansView.registerApplicationContext(this);
}
```

当`ApplicationContext`启动或停止时，它会通过`LifecycleProcessor`来与所有实现了`Lifecycle`接口的bean做状态更新，而`LifecycleProcessor`的使用前首先需要初始化。

```
protected void initLifecycleProcessor() {
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   // 如果XML文件中存在名为lifecycleProcessor的bean，使用它
   if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {
      this.lifecycleProcessor =
            beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);
      if (logger.isDebugEnabled()) {
         logger.debug("Using LifecycleProcessor [" + this.lifecycleProcessor + "]");
      }
   }
   // 否则，使用默认的DefaultLifecycleProcessor
   else {
      DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();
      defaultProcessor.setBeanFactory(beanFactory);
      this.lifecycleProcessor = defaultProcessor;
      beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);
      if (logger.isDebugEnabled()) {
         logger.debug("Unable to locate LifecycleProcessor with name '" +
               LIFECYCLE_PROCESSOR_BEAN_NAME +
               "': using default [" + this.lifecycleProcessor + "]");
      }
   }
}
```

启动所有实现了`Lifecycle`接口的bean

```
public void onRefresh() {
   startBeans(true);
   this.running = true;
}

private void startBeans(boolean autoStartupOnly) {
   // 获取所有实现了Lifecycle接口的单例bean或者SmartLifecycle接口的bean
   Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();
   Map<Integer, LifecycleGroup> phases = new HashMap<Integer, LifecycleGroup>();
   for (Map.Entry<String, ? extends Lifecycle> entry : lifecycleBeans.entrySet()) {
      Lifecycle bean = entry.getValue();
      // 如果autoStartupOnly为false或者实现了SmartLifecycle接口的bean的isAutoStartup()方法返回true
      // 此处autoStartupOnly为false，也就是只有实现SmartLifecycle接口且isAutoStartup()方法返回true的bean会被调用
      if (!autoStartupOnly || (bean instanceof SmartLifecycle && ((SmartLifecycle) bean).isAutoStartup())) {
         // 获取phase
         int phase = getPhase(bean);
         // 记录到phase组中
         LifecycleGroup group = phases.get(phase);
         if (group == null) {
            group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);
            phases.put(phase, group);
         }
         group.add(entry.getKey(), bean);
      }
   }
   // 调用start方法
   if (!phases.isEmpty()) {
      List<Integer> keys = new ArrayList<Integer>(phases.keySet());
      // phase越低的bean越先调用
      Collections.sort(keys);
      for (Integer key : keys) {
         // 一次调用一个phase组的bean
         phases.get(key).start();
      }
   }
}

public void start() {
   if (this.members.isEmpty()) {
      return;
   }
   if (logger.isInfoEnabled()) {
      logger.info("Starting beans in phase " + this.phase);
   }
   Collections.sort(this.members);
   // 调用phase组中的每一个bean
   for (LifecycleGroupMember member : this.members) {
      if (this.lifecycleBeans.containsKey(member.name)) {
         doStart(this.lifecycleBeans, member.name, this.autoStartupOnly);
      }
   }
}

private void doStart(Map<String, ? extends Lifecycle> lifecycleBeans, String beanName, boolean autoStartupOnly) {
   Lifecycle bean = lifecycleBeans.remove(beanName);
   if (bean != null && !this.equals(bean)) {
      // 启动依赖的bean
      String[] dependenciesForBean = this.beanFactory.getDependenciesForBean(beanName);
      for (String dependency : dependenciesForBean) {
         doStart(lifecycleBeans, dependency, autoStartupOnly);
      }
      // Lifecycle#isRunning()方法必须返回false才可以启动
      if (!bean.isRunning() &&
            (!autoStartupOnly || !(bean instanceof SmartLifecycle) || ((SmartLifecycle) bean).isAutoStartup())) {
         if (logger.isDebugEnabled()) {
            logger.debug("Starting bean '" + beanName + "' of type [" + bean.getClass() + "]");
         }
         try {
            // 调用start方法
            bean.start();
         }
         catch (Throwable ex) {
            throw new ApplicationContextException("Failed to start bean '" + beanName + "'", ex);
         }
         if (logger.isDebugEnabled()) {
            logger.debug("Successfully started bean '" + beanName + "'");
         }
      }
   }
}


```

当完成`ApplicationContext`初始化的时候，要通过spring中的事件发布机制来发出`ContextRefreshEvent`事件，以保证对应的监听器可以做进一步的逻辑处理。

```
public void publishEvent(ApplicationEvent event) {
   publishEvent(event, null);
}

protected void publishEvent(Object event, ResolvableType eventType) {
   Assert.notNull(event, "Event must not be null");
   if (logger.isTraceEnabled()) {
      logger.trace("Publishing event in " + getDisplayName() + ": " + event);
   }

   // Decorate event as an ApplicationEvent if necessary
   ApplicationEvent applicationEvent;
   if (event instanceof ApplicationEvent) {
      applicationEvent = (ApplicationEvent) event;
   }
   else {
      applicationEvent = new PayloadApplicationEvent<Object>(this, event);
      if (eventType == null) {
         eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();
      }
   }

   // Multicast right now if possible - or lazily once the multicaster is initialized
   // 在注册监听器的时候earlyApplicationEvents已经被设为了null，所以此时直接发布事件
   if (this.earlyApplicationEvents != null) {
      this.earlyApplicationEvents.add(applicationEvent);
   }
   else {
      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
   }

   // Publish event via parent context as well...
   if (this.parent != null) {
      if (this.parent instanceof AbstractApplicationContext) {
         ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
      }
      else {
         this.parent.publishEvent(event);
      }
   }
}
```
