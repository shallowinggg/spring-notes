前面提到了默认标签与自定义标签两种标签，两种标签的用法与解析方式存在了很大的不同，本章重点分析默认标签的解析过程。

```
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
   // 对import标签解析
   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
      importBeanDefinitionResource(ele);
   }
   // 对alias标签解析
   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
      processAliasRegistration(ele);
   }
   // 对bean标签解析
   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
      processBeanDefinition(ele, delegate);
   }
   // 对beans标签解析
   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
      // 复用
      doRegisterBeanDefinitions(ele);
   }
}
```

函数的逻辑一目了然，分别对四种不同标签做了不同的处理。

## 1. bean标签的解析及注册

在这四种标签的解析中，bean标签的解析最为复杂以及重要，因此我们从此标签开始深入分析，如果能理解此标签的解析过程，其他标签的解析过程也会迎刃而解。

```
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
   if (bdHolder != null) {
      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
      try {
         // Register the final decorated instance.
         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
      }
      catch (BeanDefinitionStoreException ex) {
         getReaderContext().error("Failed to register bean definition with name '" +
               bdHolder.getBeanName() + "'", ele, ex);
      }
      // Send registration event.
      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
   }
}
```

大致的逻辑总结如下：

1. 首先委托`BeanDefinitionDelegate`类的`parseBeanDefinitionElement`方法进行元素解析，返回`BeanDefinitionHolder`类型的实例bdHolder，经过这个方法后，bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class，name，id，alias之类的属性
2. 当返回的bdHolder不为空时，若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析
3. 解析完成后，需要对解析后的bdHolder进行注册
4. 最后发出响应事件，通知监视器，这个bean已经加载完成了

### 1.1 解析BeanDefinition

下面对各个操作进行具体分析。首先是元素解析以及类型提取
```
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
   return parseBeanDefinitionElement(ele, null);
}

public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
   // 获取id属性
   String id = ele.getAttribute(ID_ATTRIBUTE);
   // 获取name属性
   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

   List<String> aliases = new ArrayList<String>();
   // 如果指定了name属性
   if (StringUtils.hasLength(nameAttr)) {
      // 对其进行分隔，返回name数组 
      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
      // 加入到别名列表中
      aliases.addAll(Arrays.asList(nameArr));
   }

   String beanName = id;
   // 如果没有指定id属性，但是指定了name属性
   if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
      // 将别名数组中的第一个作为这个bean的id
      beanName = aliases.remove(0);
      if (logger.isDebugEnabled()) {
         logger.debug("No XML 'id' specified - using '" + beanName +
               "' as bean name and " + aliases + " as aliases");
      }
   }
   // 检查这个bean的id和别名是否已经被其他bean使用
   if (containingBean == null) {
      checkNameUniqueness(beanName, aliases, ele);
   }

   // 解析<bean />标签中的其他属性
   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
   if (beanDefinition != null) {
      // 如果既没有指定id也没有指定name属性
      if (!StringUtils.hasText(beanName)) {
         try {
            // 尝试为这个bean自动生成一个名字
            if (containingBean != null) {
               beanName = BeanDefinitionReaderUtils.generateBeanName(
                     beanDefinition, this.readerContext.getRegistry(), true);
            }
            else {
               beanName = this.readerContext.generateBeanName(beanDefinition);
               // Register an alias for the plain bean class name, if still possible,
               // if the generator returned the class name plus a suffix.
               // This is expected for Spring 1.2/2.0 backwards compatibility.
               String beanClassName = beanDefinition.getBeanClassName();
               if (beanClassName != null &&
                     beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                  aliases.add(beanClassName);
               }
            }
            if (logger.isDebugEnabled()) {
               logger.debug("Neither XML 'id' nor 'name' specified - " +
                     "using generated bean name [" + beanName + "]");
            }
         }
         catch (Exception ex) {
            error(ex.getMessage(), ele);
            return null;
         }
      }
      String[] aliasesArray = StringUtils.toStringArray(aliases);
      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
   }

   return null;
}

protected void checkNameUniqueness(String beanName, List<String> aliases, Element beanElement) {
   String foundName = null;

   // 检查id是否被使用
   if (StringUtils.hasText(beanName) && this.usedNames.contains(beanName)) {
      foundName = beanName;
   }
   // 检查别名是否被使用
   if (foundName == null) {
      foundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);
   }
   // 如果被使用了，记录错误信息
   if (foundName != null) {
      error("Bean name '" + foundName + "' is already used in this <beans> element", beanElement);
   }

   // 增加到名称集中
   this.usedNames.add(beanName);
   this.usedNames.addAll(aliases);
}
```

以上则是对默认标签解析的全过程了。

1. 提取元素的id以及name属性
2. 进一步解析其他所有属性并统一封装到`GenericBeanDefinition`类型的实例中
3. 如果检测到bean没有指定beanName，那么使用默认规则为此Bean生成beanName
4. 将获取到的信息封装到`BeanDefinitionHolder`的实例中

第一步内容十分简单，现在查看步骤二中对标签其他属性的解析过程。

```
public AbstractBeanDefinition parseBeanDefinitionElement(
      Element ele, String beanName, BeanDefinition containingBean) {

   this.parseState.push(new BeanEntry(beanName));

   String className = null;
   // 获取class属性
   if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
   }

   try {
      String parent = null;
      // 获取parent属性
      if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
         parent = ele.getAttribute(PARENT_ATTRIBUTE);
      }
      // 使用给定的类名和父bean名称创建一个GenericBeanDefinition
      AbstractBeanDefinition bd = createBeanDefinition(className, parent);

      // 解析<bean />标签剩余属性
      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
      // 获取<description />标签中的内容，设置描述信息
      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

      // 解析<meta />元素
      parseMetaElements(ele, bd);
      // 解析<lookup-method />子元素
      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
      // 解析<replaced-method />子元素
      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

      // 解析<constructor-arg />元素
      parseConstructorArgElements(ele, bd);
      // 解析<property />元素
      parsePropertyElements(ele, bd);
      // 解析<qualify />元素
      parseQualifierElements(ele, bd);

      bd.setResource(this.readerContext.getResource());
      bd.setSource(extractSource(ele));

      return bd;
   }
   catch (ClassNotFoundException ex) {
      error("Bean class [" + className + "] not found", ele, ex);
   }
   catch (NoClassDefFoundError err) {
      error("Class that bean class [" + className + "] depends on not found", ele, err);
   }
   catch (Throwable ex) {
      error("Unexpected failure during bean definition parsing", ele, ex);
   }
   finally {
      this.parseState.pop();
   }

   return null;
}

protected AbstractBeanDefinition createBeanDefinition(String className, String parentName)
      throws ClassNotFoundException {

   return BeanDefinitionReaderUtils.createBeanDefinition(
         parentName, className, this.readerContext.getBeanClassLoader());
}
```

#### 1.1.1. 创建用于属性承载的BeanDefinition

`BeanDefinition`是一个接口，在Spring中有三种实现：`RootBeanDefinition`，`ChildBeanDefinition`以及`GenericBeanDefinition`。这三种实现都继承了`AbstractBeanDefinition`，其中`BeanDefinition`是配置文件`<bean />`元素在容器中的内部表现形式。`<bean />`元素标签拥有class，scope，lazy-init等配置属性，`BeanDefinition`则提供了相应的beanClass，scope，lazyinit属性，`BeanDefinition`和`<bean />`中的属性是一一对应的。其实`RootBeanDefinition`是最常用的实现类，它对应一般的`<bean />`元素，`GenericBeanDefinition`是Spring 2.5版本后新加入的bean文件配置属性定义类。

在配置文件中可以定义父bean和子bean，父bean用`RootBeanDefinition`表示，而子bean用`ChildBeanDefinition`表示，没有父bean的bean就用`RootBeanDefinition`表示。

Spring通过`BeanDefinition`将配置文件中的`<bean />`配置信息转换为容器的内部表示，并将这些`BeanDefinition`注册到`BeanDefinitionRegistry`中。Spring容器中的`BeanDefinitionRegistry`就像Spring配置信息的内存数据库，主要以map的形式表示，后续操作直接从`BeanDefinitionRegistry`中读取配置信息。

由此可知，要解析属性首先要创建用于承载属性的实例，也就是创建`GenericBeanDefinition`类的实例。

```
protected AbstractBeanDefinition createBeanDefinition(String className, String parentName)
      throws ClassNotFoundException {

   return BeanDefinitionReaderUtils.createBeanDefinition(
         parentName, className, this.readerContext.getBeanClassLoader());
}

public static AbstractBeanDefinition createBeanDefinition(
     String parentName, String className, ClassLoader classLoader) throws ClassNotFoundException {

   GenericBeanDefinition bd = new GenericBeanDefinition();
   bd.setParentName(parentName);
   if (className != null) {
      if (classLoader != null) {
         bd.setBeanClass(ClassUtils.forName(className, classLoader));
      }
      else {
         bd.setBeanClassName(className);
      }
   }
   return bd;
}
```

#### 1.1.2. 解析各种属性

当我们创建了bean信息后，便可以对bean信息的各种属性进行解析了，首先我们进入`parseBeanDefinitionAttributes`方法。此方法是对element所有的属性进行解析：

```
public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
      BeanDefinition containingBean, AbstractBeanDefinition bd) {

   // 如果这个bean指定了singleton属性，那么记录错误信息，因为这个属性已经不再使用了
   if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
      error("Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration", ele);
   }
   // 获取scope属性并设置AbstractBeanDefinition的scope属性
   else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
      bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
   }
   // 如果没有指定scope属性并且这个bean是一个内部bean，则尝试从外部bean中获取
   else if (containingBean != null) {
      // Take default from containing bean in case of an inner bean definition.
      bd.setScope(containingBean.getScope());
   }

   // 获取abstract属性
   if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
      // 默认为false，只有当它为true时才更改AbstractBeanDefinition
      bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
   }

   // 获取lazy-init属性
   String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
   // 如果它的值为default，尝试获取在<beans />标签中指定的default-lazy-init属性
   if (DEFAULT_VALUE.equals(lazyInit)) {
      lazyInit = this.defaults.getLazyInit();
   }
   bd.setLazyInit(TRUE_VALUE.equals(lazyInit));

   // 获取autowire属性，并将它转换为int表示
   String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
   bd.setAutowireMode(getAutowireMode(autowire));

   // 获取dependency-check属性
   String dependencyCheck = ele.getAttribute(DEPENDENCY_CHECK_ATTRIBUTE);
   bd.setDependencyCheck(getDependencyCheck(dependencyCheck));

   // 获取depends-on属性
   if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
      String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
      bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
   }

   // 获取autowire-candidate属性
   String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
   if ("".equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {
      String candidatePattern = this.defaults.getAutowireCandidates();
      if (candidatePattern != null) {
         String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
         bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
      }
   }
   else {
      bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
   }

   // 获取primary属性
   if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
      bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
   }

   // 获取init-method属性
   if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
      String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
      if (!"".equals(initMethodName)) {
         bd.setInitMethodName(initMethodName);
      }
   }
   else {
      if (this.defaults.getInitMethod() != null) {
         bd.setInitMethodName(this.defaults.getInitMethod());
         bd.setEnforceInitMethod(false);
      }
   }

   // 获取destroy-method属性
   if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
      String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
      bd.setDestroyMethodName(destroyMethodName);
   }
   else {
      if (this.defaults.getDestroyMethod() != null) {
         bd.setDestroyMethodName(this.defaults.getDestroyMethod());
         bd.setEnforceDestroyMethod(false);
      }
   }

   // 获取factory-method属性
   if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
      bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
   }
   if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
      bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
   }

   return bd;
}


public int getAutowireMode(String attValue) {
   String att = attValue;
   if (DEFAULT_VALUE.equals(att)) {
      att = this.defaults.getAutowire();
   }
   int autowire = AbstractBeanDefinition.AUTOWIRE_NO;
   if (AUTOWIRE_BY_NAME_VALUE.equals(att)) {
      autowire = AbstractBeanDefinition.AUTOWIRE_BY_NAME;
   }
   else if (AUTOWIRE_BY_TYPE_VALUE.equals(att)) {
      autowire = AbstractBeanDefinition.AUTOWIRE_BY_TYPE;
   }
   else if (AUTOWIRE_CONSTRUCTOR_VALUE.equals(att)) {
      autowire = AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR;
   }
   else if (AUTOWIRE_AUTODETECT_VALUE.equals(att)) {
      autowire = AbstractBeanDefinition.AUTOWIRE_AUTODETECT;
   }
   // Else leave default value.
   return autowire;
}
```

我们可以看出Spring完成了对所有属性的解析，这些属性中有许多我们经常使用的，同时也有不熟悉的或没用过的，可以查阅资料进一步了解每个属性。同时，注意很多属性在`AbstractBeanDefinition`中都设置了默认值，只有设置的属性和默认值不同时，才对这个属性进行更改，并且`<beans />`标签中还能指定一些默认属性，所以如果这些属性没有在`<bean />`标签中指定，那么会尝试从默认值中获取。下面是`AbstractBeanDefinition`中各种属性的默认值：

```
public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
		implements BeanDefinition, Cloneable {

	public static final String SCOPE_DEFAULT = "";

	public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;

	public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;

	public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;

	public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;

	/**
	 * Constant that indicates determining an appropriate autowire strategy
	 * through introspection of the bean class.
	 * @see #setAutowireMode
	 * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies,
	 * use annotation-based autowiring for clearer demarcation of autowiring needs.
	 */
	@Deprecated
	public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;

	public static final int DEPENDENCY_CHECK_NONE = 0;

	public static final int DEPENDENCY_CHECK_OBJECTS = 1;

	public static final int DEPENDENCY_CHECK_SIMPLE = 2;

	public static final int DEPENDENCY_CHECK_ALL = 3;

	public static final String INFER_METHOD = "(inferred)";

	private volatile Object beanClass;

	private String scope = SCOPE_DEFAULT;

	private boolean abstractFlag = false;

	private boolean lazyInit = false;

	private int autowireMode = AUTOWIRE_NO;

	private int dependencyCheck = DEPENDENCY_CHECK_NONE;

	private String[] dependsOn;

	private boolean autowireCandidate = true;

	private boolean primary = false;

	private final Map<String, AutowireCandidateQualifier> qualifiers =
			new LinkedHashMap<String, AutowireCandidateQualifier>(0);

	private boolean nonPublicAccessAllowed = true;

	private boolean lenientConstructorResolution = true;

	private String factoryBeanName;

	private String factoryMethodName;

	private ConstructorArgumentValues constructorArgumentValues;

	private MutablePropertyValues propertyValues;

	private MethodOverrides methodOverrides = new MethodOverrides();

	private String initMethodName;

	private String destroyMethodName;

	private boolean enforceInitMethod = true;

	private boolean enforceDestroyMethod = true;

	private boolean synthetic = false;

	private int role = BeanDefinition.ROLE_APPLICATION;

	private String description;

	private Resource resource;

```

#### 1.1.3. 解析子元素meta

在开始解析元数据的分析前，我们先回顾元数据meta的使用

```
<bean id=testBean” class=”bean.TestBean”>
    <meta key=”testStr” value=”aaaaa” />
</bean>
```

这段代码并不会体现在`TestBean`的属性中，而是一个额外的声明，当需要使用里面的信息时可以通过`BeanDefinition的getAttribute(key)`方法进行获取。

对meta属性的解析代码如下：

```
public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
   // 获取<bean />标签的子节点
   NodeList nl = ele.getChildNodes();
   for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      // 如果这个元素在默认命名空间中并且名称为meta
      if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {
         Element metaElement = (Element) node;
         // 获取key属性
         String key = metaElement.getAttribute(KEY_ATTRIBUTE);
         // 获取value属性
         String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
         BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
         attribute.setSource(extractSource(metaElement));
         //记录信息  attributeAccessor为前面的GenericBeanDefiniton实例bd
         attributeAccessor.addMetadataAttribute(attribute);
      }
   }
}

private boolean isCandidateElement(Node node) {
   return (node instanceof Element && (isDefaultNamespace(node) || !isDefaultNamespace(node.getParentNode())));
}
```

#### 1.1.4. 解析子元素lookup-method

关于lookup-method属性已经在前面详细介绍过，查看 [Lookup Method Injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lookup-method-injection) 获取更多信息。

```
<lookup-method bean="" name="" />
```

```
public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
   NodeList nl = beanEle.getChildNodes();
   for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      // 如果子元素的名称为 lookup-method
      if (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
         Element ele = (Element) node;
         // 获取name属性
         String methodName = ele.getAttribute(NAME_ATTRIBUTE);
         // 获取bean属性
         String beanRef = ele.getAttribute(BEAN_ELEMENT);
         // 封装这些信息并记录
         LookupOverride override = new LookupOverride(methodName, beanRef);
         override.setSource(extractSource(ele));
         overrides.addOverride(override);
      }
   }
}
```

#### 1.1.5. 解析子元素replaced-method

关于replaced-method的作用以及使用，查看[Arbitrary Method Replacement](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-arbitrary-method-replacement)获取更多信息。

```
<replaced-method name="" replacer="">
    <arg-type match="" />
</replaced-method>
```
```
public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
   NodeList nl = beanEle.getChildNodes();
   for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      // 如果子元素名称为replaced-method
      if (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {
         Element replacedMethodEle = (Element) node;
         // 获取要替换的方法名称
         String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);
         // 获取替换器名称
         String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);
         ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);
         // Look for arg-type match elements.
         // 查询arg-type元素
         List<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);
         for (Element argTypeEle : argTypeEles) {
            // 获取match属性
            String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);
            match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));
            if (StringUtils.hasText(match)) {
               // 记录参数信息
               replaceOverride.addTypeIdentifier(match);
            }
         }
         replaceOverride.setSource(extractSource(replacedMethodEle));
         // 记录replaced-method
         overrides.addOverride(replaceOverride);
      }
   }
}
```

我们可以看到无论是lookup-method还是replaced-method都是构造一个`MethodOverride`，并最终记录在了methodOverrides属性中。关于这个属性后续章节将会详细介绍。

#### 1.1.6. 解析子元素constructor-arg

```
<constructor-arg index="" type="" name="" ref="" value="" />
```

```
public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
   // 获取index属性
   String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
   // 获取type属性
   String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
   // 获取name属性
   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
   // 如果指定了index属性
   if (StringUtils.hasLength(indexAttr)) {
      try {
         // 转换为int值
         int index = Integer.parseInt(indexAttr);
         if (index < 0) {
            error("'index' cannot be lower than 0", ele);
         }
         else {
            try {
               this.parseState.push(new ConstructorArgumentEntry(index));
               // 获取参数值
               Object value = parsePropertyValue(ele, bd, null);
               // 记录这个值
               ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
               // 如果指定了type属性，记录
               if (StringUtils.hasLength(typeAttr)) {
                  valueHolder.setType(typeAttr);
               }
               // 如果指定了name属性，记录
               if (StringUtils.hasLength(nameAttr)) {
                  valueHolder.setName(nameAttr);
               }
               valueHolder.setSource(extractSource(ele));
               // 如果已经指定了这个index，那么记录错误信息
               if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {
                  error("Ambiguous constructor-arg entries for index " + index, ele);
               }
               // 否则，记录这个index
               else {
                  bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);
               }
            }
            finally {
               this.parseState.pop();
            }
         }
      }
      catch (NumberFormatException ex) {
         error("Attribute 'index' of tag 'constructor-arg' must be an integer", ele);
      }
   }
   // 与前面过程类似
   else {
      try {
         this.parseState.push(new ConstructorArgumentEntry());
         Object value = parsePropertyValue(ele, bd, null);
         ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
         if (StringUtils.hasLength(typeAttr)) {
            valueHolder.setType(typeAttr);
         }
         if (StringUtils.hasLength(nameAttr)) {
            valueHolder.setName(nameAttr);
         }
         valueHolder.setSource(extractSource(ele));
         bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);
      }
      finally {
         this.parseState.pop();
      }
   }
}
```

上述一段代码看似复杂，但是设计的逻辑并不复杂，首先是提取constructor-arg上必要的属性(index, type, name)。

如果配置中指定了index属性 ，那么操作步骤如下：

1. 解析constructor-arg的子元素
2. 使用`ConstructorArgumentValues.ValueHolder`类型来封装解析出来的元素
3. 将type，name和index属性一并封装到其中并增加到`BeanDefinition`的constructorArgumentValues的indexedArgumentValues属性中

如果没有指定index属性，那么操作步骤如下：

1. 解析constructor-arg的子元素
2. 使用`ConstructorArgumentValues.ValueHolder`类型来封装解析出来的元素
3. 将type，name和index属性一并封装到其中 并增加到`BeanDefinition`的constructorArgumentValues的genericArgumentValues属性中

可以看出，对是否指定index属性，Spring的处理流程是不同的，关键在于属性被保存的位置。了解了整个流程后，进一步了解解析构造函数配置中子元素的过程：

```
public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {
   String elementName = (propertyName != null) ?
               "<property> element for property '" + propertyName + "'" :
               "<constructor-arg> element";

   // Should only have one child element: ref, value, list, etc.
   NodeList nl = ele.getChildNodes();
   Element subElement = null;
   // 如果有子元素
   for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      // 忽略description和meta子元素
      if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&
            !nodeNameEquals(node, META_ELEMENT)) {
         // Child element is what we're looking for.
         // 只能有ref, value, list等中的一种子元素
         if (subElement != null) {
            error(elementName + " must not contain more than one sub-element", ele);
         }
         else {
            subElement = (Element) node;
         }
      }
   }

   // 查看是否指定了ref或者value属性
   boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
   boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
   // 如果同时指定了这两种属性或者
   // 既指定了属性又指定了子元素，那么不符合规则，记录错误信息
   if ((hasRefAttribute && hasValueAttribute) ||
         ((hasRefAttribute || hasValueAttribute) && subElement != null)) {
      error(elementName +
            " is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele);
   }

   // 如果只指定了ref属性
   if (hasRefAttribute) {
      // 获取它的值并记录下来 
      String refName = ele.getAttribute(REF_ATTRIBUTE);
      if (!StringUtils.hasText(refName)) {
         error(elementName + " contains empty 'ref' attribute", ele);
      }
      RuntimeBeanReference ref = new RuntimeBeanReference(refName);
      ref.setSource(extractSource(ele));
      return ref;
   }
   // 如果只指定了value属性
   else if (hasValueAttribute) {
      // 获取它的值并记录下来 
      TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
      valueHolder.setSource(extractSource(ele));
      return valueHolder;
   }
   // 如果只指定了子元素，那么解析子元素
   else if (subElement != null) {
      return parsePropertySubElement(subElement, bd);
   }
   else {
      // Neither child element nor "ref" or "value" attribute found.
      error(elementName + " must specify a ref or value", ele);
      return null;
   }
}
```

从代码上看，对构造方法中属性元素的解析，经历了以下几个过程：

1. 略过description或meta
2. 提取ref和value属性，以便于验证规则的正确性，其规则在constructor-arg上不存在以下情况：（1）同时既有ref属性又有value属性（2）存在ref属性或者value属性且又有子元素
3. ref属性的处理。使用`RuntimeBeanReference`封装对应的ref名称
4. value属性的处理。使用`TypedStringValue`封装
5. 子元素的处理。例如:
```
<constructor-arg>
    <ref bean="dataSource" />
</constructor-arg>
```

`parsePropertySubElement`方法实现了对各种子元素的分类处理：

```
<constructor-arg>
    <bean />
    <ref bean="" parent="" />
    <idref bean="" />
    <value type="" />
    <null />
    <array merge="" value-type=""></array>
    <list merge="" value-type=""></list>
    <set merge="" value-type=""></set>
    <map merge="" key-type="" value-type=""></map>
    <props merge="" value-type=""></props>
</constructor-arg>
```

```
public Object parsePropertySubElement(Element ele, BeanDefinition bd) {
   return parsePropertySubElement(ele, bd, null);
}

public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) {
   // 如果不处于默认命名空间，则解析自定义元素
   if (!isDefaultNamespace(ele)) {
      return parseNestedCustomElement(ele, bd);
   }
   // 如果子元素为bean
   else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
      // 复用parseBeanDefinitionElement方法
      BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
      if (nestedBd != null) {
         nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
      }
      return nestedBd;
   }
   // 如果子元素为ref
   else if (nodeNameEquals(ele, REF_ELEMENT)) {
      // A generic reference to any name of any bean.
     // 获取bean属性
      String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
      boolean toParent = false;
      // 如果没有指定bean属性，获取local属性，注意此属性在Spring 4.0 XSD后不再支持
      if (!StringUtils.hasLength(refName)) {
         // A reference to the id of another bean in the same XML file.
         refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);
         // 如果也没有指定local属性，获取parent属性
         if (!StringUtils.hasLength(refName)) {
            // A reference to the id of another bean in a parent context.
            refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
            toParent = true;
            if (!StringUtils.hasLength(refName)) {
               error("'bean', 'local' or 'parent' is required for <ref> element", ele);
               return null;
            }
         }
      }
      if (!StringUtils.hasText(refName)) {
         error("<ref> element contains empty target attribute", ele);
         return null;
      }
      RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
      ref.setSource(extractSource(ele));
      return ref;
   }
   // 如果子元素为idref
   else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
      return parseIdRefElement(ele);
   }
   // 如果子元素为value
   else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
      return parseValueElement(ele, defaultValueType);
   }
   // 如果子元素为null
   else if (nodeNameEquals(ele, NULL_ELEMENT)) {
      // It's a distinguished null value. Let's wrap it in a TypedStringValue
      // object in order to preserve the source location.
      TypedStringValue nullHolder = new TypedStringValue(null);
      nullHolder.setSource(extractSource(ele));
      return nullHolder;
   }
   // 如果子元素为array
   else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
      return parseArrayElement(ele, bd);
   }
   // 如果子元素为list
   else if (nodeNameEquals(ele, LIST_ELEMENT)) {
      return parseListElement(ele, bd);
   }
   // 如果子元素为set
   else if (nodeNameEquals(ele, SET_ELEMENT)) {
      return parseSetElement(ele, bd);
   }
   // 如果子元素为map
   else if (nodeNameEquals(ele, MAP_ELEMENT)) {
      return parseMapElement(ele, bd);
   }
   // 如果子元素为props
   else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
      return parsePropsElement(ele);
   }
   else {
      error("Unknown property sub-element: [" + ele.getNodeName() + "]", ele);
      return null;
   }
}
```

可以看到，在上面的方法中实现了对所有子元素的分类处理。这些子元素的解析大同小异，感兴趣自己查看即可，此处不再多说。

#### 1.1.7. 解析子元素property

```
<property name="" value="" ref="" />
```
```
public void parsePropertyElement(Element ele, BeanDefinition bd) {
   // 获取name属性，此属性必须指定
   String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
   if (!StringUtils.hasLength(propertyName)) {
      error("Tag 'property' must have a 'name' attribute", ele);
      return;
   }
   this.parseState.push(new PropertyEntry(propertyName));
   try {
      // 如果已经指定了这个属性(即同一个bean中不能包含相同的property)，记录错误信息
      if (bd.getPropertyValues().contains(propertyName)) {
         error("Multiple 'property' definitions for property '" + propertyName + "'", ele);
         return;
      }
      // 与解析constructor-arg元素一样，不过此处指定了名称
      Object val = parsePropertyValue(ele, bd, propertyName);
      // 使用PropertyValue封装
      PropertyValue pv = new PropertyValue(propertyName, val);
      // 解析meta子元素并记录
      parseMetaElements(ele, pv);
      pv.setSource(extractSource(ele));
      bd.getPropertyValues().addPropertyValue(pv);
   }
   finally {
      this.parseState.pop();
   }
}
```

可以看到上面函数与构造函数注入方式不同的是将返回值使用`PropertyValue`进行封装，并记录在propertyValues属性中。

#### 1.1.8. 解析子元素Qualifier

对于qualifier元素的获取，我们更多使用的注解的方式，在使用Spring框架中的自动注入时，Spring容器中匹配的候选Bean数目必须有且仅有一个。当找不到一个匹配的Bean时，Spring容器将会抛出异常。

Spring允许我们通过qualifier指定注入的bean名称，这样歧义就消除了。关于这个属性，查看[1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers)获取更多信息。

```
<bean id="hello" class="common.Hello">
    <qualifier type="org.springframework.beans.factory.annotation.Qualifier" value="aa" />
</bean>

<bean class="example.SimpleMovieCatalog">
    <qualifier type="MovieQualifier">
        <attribute key="format" value="VHS"/>
        <attribute key="genre" value="Comedy"/>
    </qualifier>
</bean>
```
```
public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) {
   NodeList nl = beanEle.getChildNodes();
   for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      // 如果子元素为qualifier
      if (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ELEMENT)) {
         parseQualifierElement((Element) node, bd);
      }
   }
}

public void parseQualifierElement(Element ele, AbstractBeanDefinition bd) {
   // 获取type属性
   String typeName = ele.getAttribute(TYPE_ATTRIBUTE);
   if (!StringUtils.hasLength(typeName)) {
      error("Tag 'qualifier' must have a 'type' attribute", ele);
      return;
   }
   this.parseState.push(new QualifierEntry(typeName));
   try {
      AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);
      qualifier.setSource(extractSource(ele));
      // 获取value属性
      String value = ele.getAttribute(VALUE_ATTRIBUTE);
      if (StringUtils.hasLength(value)) {
         qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value);
      }
      NodeList nl = ele.getChildNodes();
      for (int i = 0; i < nl.getLength(); i++) {
         Node node = nl.item(i);
         // 如果存在attribute子元素
         if (isCandidateElement(node) && nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) {
            Element attributeEle = (Element) node;
            // 获取key属性
            String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE);
            // 获取value属性
            String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE);
            // 记录这两个属性
            if (StringUtils.hasLength(attributeName) && StringUtils.hasLength(attributeValue)) {
               BeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue);
               attribute.setSource(extractSource(attributeEle));
               qualifier.addMetadataAttribute(attribute);
            }
            else {
               error("Qualifier 'attribute' tag must have a 'name' and 'value'", attributeEle);
               return;
            }
         }
      }
      bd.addQualifier(qualifier);
   }
   finally {
      this.parseState.pop();
   }
}
```

至此，`<bean />`元素中的属性已经解析完毕。

### 1.2 AbstractBeanDefinition属性

```
public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
      implements BeanDefinition, Cloneable {

   /**
    * Constant for the default scope name: {@code ""}, equivalent to singleton
    * status unless overridden from a parent bean definition (if applicable).
    */
   public static final String SCOPE_DEFAULT = "";

   /**
    * Constant that indicates no autowiring at all.
    * @see #setAutowireMode
    */
   public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;

   /**
    * Constant that indicates autowiring bean properties by name.
    * @see #setAutowireMode
    */
   public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;

   /**
    * Constant that indicates autowiring bean properties by type.
    * @see #setAutowireMode
    */
   public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;

   /**
    * Constant that indicates autowiring a constructor.
    * @see #setAutowireMode
    */
   public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;

   /**
    * Constant that indicates determining an appropriate autowire strategy
    * through introspection of the bean class.
    * @see #setAutowireMode
    * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies,
    * use annotation-based autowiring for clearer demarcation of autowiring needs.
    */
   @Deprecated
   public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;

   /**
    * Constant that indicates no dependency check at all.
    * @see #setDependencyCheck
    */
   public static final int DEPENDENCY_CHECK_NONE = 0;

   /**
    * Constant that indicates dependency checking for object references.
    * @see #setDependencyCheck
    */
   public static final int DEPENDENCY_CHECK_OBJECTS = 1;

   /**
    * Constant that indicates dependency checking for "simple" properties.
    * @see #setDependencyCheck
    * @see org.springframework.beans.BeanUtils#isSimpleProperty
    */
   public static final int DEPENDENCY_CHECK_SIMPLE = 2;

   /**
    * Constant that indicates dependency checking for all properties
    * (object references as well as "simple" properties).
    * @see #setDependencyCheck
    */
   public static final int DEPENDENCY_CHECK_ALL = 3;

   /**
    * Constant that indicates the container should attempt to infer the
    * {@link #setDestroyMethodName destroy method name} for a bean as opposed to
    * explicit specification of a method name. The value {@value} is specifically
    * designed to include characters otherwise illegal in a method name, ensuring
    * no possibility of collisions with legitimately named methods having the same
    * name.
    * <p>Currently, the method names detected during destroy method inference
    * are "close" and "shutdown", if present on the specific bean class.
    */
   public static final String INFER_METHOD = "(inferred)";

   private volatile Object beanClass;
   // bean作用范围，对应属性scope
   private String scope = SCOPE_DEFAULT;
   // 是否是抽象，对应属性abstract
   private boolean abstractFlag = false;
   // 是否延迟加载，对应属性lazy-init
   private boolean lazyInit = false;
   // 自动注入模式，对应属性autowire
   private int autowireMode = AUTOWIRE_NO;
   // 依赖检查，Spring3.0后弃用
   private int dependencyCheck = DEPENDENCY_CHECK_NONE;
   // 用于表示一个bean的实例化依靠另一个bean的先实例化，对应bean属性 depend-on
   private String[] dependsOn;
   // autowire-candidate属性设置为false，这样容器在查找自动装配对象时，将不考虑该bean，
   // 即它不会被考虑作为其他bean自动装配的候选者，但是该bean本身还是可以使用自动装配来注入其他bean的。
   // 对应属性 autowire-candidate
   private boolean autowireCandidate = true;
   // 自动装配出现多个候选者时，将作为首选者，对应属性primary
   private boolean primary = false;
   // 用于记录qualifier，对应子元素qualifier
   private final Map<String, AutowireCandidateQualifier> qualifiers =
         new LinkedHashMap<String, AutowireCandidateQualifier>(0);
   // 允许访问非公开的构造器和方法，程序设置(用于反射)
   private boolean nonPublicAccessAllowed = true;
   /*是否以一种宽松的模式解析构造函数默认为true
     如果为false，则在如下情况
     interface ITest {}
     class ITestImpl implements ITest{};
     class Main {
         Main(ITest i) {};
         Main(ITestImpl i) {};
     }
     抛出异常，因为Spring无法准确定位使用哪个构造函数，程序设置
   */
   private boolean lenientConstructorResolution = true;
   // 对应bean属性factory-bean
   private String factoryBeanName;
   // 对应bean属性factory-method
   private String factoryMethodName;
   // 记录构造函数注入属性，对应属性constructor-arg
   private ConstructorArgumentValues constructorArgumentValues;
   // 普通属性集合
   private MutablePropertyValues propertyValues;
   // 方法重写的持有者，记录lookup-method，replaced-method
   private MethodOverrides methodOverrides = new MethodOverrides();
   // 初始化方法，对应属性init-method
   private String initMethodName;
   // 销毁方法，对应属性destroy-method
   private String destroyMethodName;
   // 是否执行init-method，程序设置
   private boolean enforceInitMethod = true;
   // 是否执行destroy-method，程序设置
   private boolean enforceDestroyMethod = true;
   // 是否是用户定义的而不是应用程序本身定义的，创建AOP时为true，程序设置
   private boolean synthetic = false;
   // 定义这个bean的应用，APPLICATION：用户；INFRASTRUCTURE：完全内部使用，与用户无关；
   // SUPPORT：某些复杂配置的一部分，程序设置
   private int role = BeanDefinition.ROLE_APPLICATION;
   // bean的描述信息
   private String description;
   // 这个bean的资源
   private Resource resource;
}
```

### 1.3 解析默认标签的自定义标签元素

到这里我们已经完成了分析默认标签的解析与提取过程，或许涉及的内容太多，我们已经忘了我们从哪个函数开始的了，我们再次回顾下默认标签解析函数的起始函数。

```
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
   if (bdHolder != null) {
      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
      try {
         // Register the final decorated instance.
         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
      }
      catch (BeanDefinitionStoreException ex) {
         getReaderContext().error("Failed to register bean definition with name '" +
               bdHolder.getBeanName() + "'", ele, ex);
      }
      // Send registration event.
      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
   }
}
```

我们已经用了大量的篇幅分析了`BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);`这句代码，接下来我们要进行`bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);`这句代码的分析，首先大致了解下这句代码的作用，其实我们可以从语义上分析：如果需要的话就对beanDefinition进行装饰，那么这句代码到底是什么功能呢？其实这句代码适用于这样的场景：

```
<bean id=”test” class=”test.MyClass”>
    <mybean:user username=”aaa” />
</bean>
```

当Spring中的bean使用的是默认的标签配置，但是其中的子元素却使用了自定义的配置时，这句代码便会起作用了。之前讲过，对bean的解析分为两种类型，一种是默认标签的解析，一种是自定义标签的解析，这不正是自定义标签的解析么。为什么会在默认类型解析中单独增加一个方法处理呢？这个自定义类型并不是以bean的形式出现的，之前说的两种类型的不同处理只是针对bean的，这里的自定义类型其实是属性。我们继续分析这段代码的逻辑。

```
public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder) {
   return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);
}

public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
      Element ele, BeanDefinitionHolder definitionHolder, BeanDefinition containingBd) {

   BeanDefinitionHolder finalDefinition = definitionHolder;

   // Decorate based on custom attributes first.
   NamedNodeMap attributes = ele.getAttributes();
   // 遍历所有的属性，查看是否有适用于修饰的属性
   for (int i = 0; i < attributes.getLength(); i++) {
      Node node = attributes.item(i);
      finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
   }

   // Decorate based on custom nested elements.
   // 遍历所有的子元素，查看是否有适用于修饰的子元素
   NodeList children = ele.getChildNodes();
   for (int i = 0; i < children.getLength(); i++) {
      Node node = children.item(i);
      if (node.getNodeType() == Node.ELEMENT_NODE) {
         finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
      }
   }
   return finalDefinition;
}

```

我们可以看到这个方法对元素的所有属性以及子节点调用了`decorateIfRequired`方法

```
public BeanDefinitionHolder decorateIfRequired(
      Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) {

   // 获取标签命名空间
   String namespaceUri = getNamespaceURI(node);
   // 如果是自定义命名空间
   if (!isDefaultNamespace(namespaceUri)) {
      // 根据命名空间找到对应的处理器
      NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
      if (handler != null) {
         return handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));
      }
      else if (namespaceUri != null && namespaceUri.startsWith("http://www.springframework.org/")) {
         error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", node);
      }
      else {
         // A custom namespace, not to be handled by Spring - maybe "xml:...".
         if (logger.isDebugEnabled()) {
            logger.debug("No Spring NamespaceHandler found for XML schema namespace [" + namespaceUri + "]");
         }
      }
   }
   return originalDef;
}
```

程序条理十分清楚，首先获取属性或者元素的命名空间，以此来判断该元素或属性是否适用于自定义标签的解析条件，找出自定义标签所对应的`NamespaceHandler`并进行进一步解析。在自定义标签解析的章节会具体讲解。

### 1.4 注册解析的BeanDefinition

对于配置文件，解析也解析完了，装饰也装饰完了，对于得到的`BeanDefinition`已经可以满足后续的要求了，唯一还剩下的工作就是注册了，也就是`BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())`代码的解析了。

```
public static void registerBeanDefinition(
      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
      throws BeanDefinitionStoreException {

   // Register bean definition under primary name.
   // 使用id来注册这个bean
   String beanName = definitionHolder.getBeanName();
   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

   // Register aliases for bean name, if any.
   // 如果存在别名，注册所有别名
   String[] aliases = definitionHolder.getAliases();
   if (aliases != null) {
      for (String alias : aliases) {
         registry.registerAlias(beanName, alias);
      }
   }
}
```

#### 1.4.1 通过beanName注册BeanDefinition

对于`BeanDefinition`的注册，或许很多人认为的方式就是将`BeanDefinition`直接放入map中就好了，使用beanName作为key。确实，Spring就是这么做的，只不过除此以外，它还做了别的事情。

```
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException {

   Assert.hasText(beanName, "Bean name must not be empty");
   Assert.notNull(beanDefinition, "BeanDefinition must not be null");

   if (beanDefinition instanceof AbstractBeanDefinition) {
      try {
          // 注册前的最后一次校验，这里的校验不同于之前xml文件校验，
          // 主要是对AbstractBeanDefinition属性的methodOverrides进行校验，
          // 校验methodOverrides是否与工厂方法并存或者methodOverrides对应的方法是否存在
         ((AbstractBeanDefinition) beanDefinition).validate();
      }
      catch (BeanDefinitionValidationException ex) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               "Validation of bean definition failed", ex);
      }
   }

   BeanDefinition oldBeanDefinition;

   oldBeanDefinition = this.beanDefinitionMap.get(beanName);
   if (oldBeanDefinition != null) {
      //如果对应的bean已经注册并且在配置中配置了bean不允许被覆盖，则抛出异常
      if (!isAllowBeanDefinitionOverriding()) {
         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
               "Cannot register bean definition [" + beanDefinition + "] for bean '" + beanName +
               "': There is already [" + oldBeanDefinition + "] bound.");
      }
      else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {
         // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
         if (this.logger.isWarnEnabled()) {
            this.logger.warn("Overriding user-defined bean definition for bean '" + beanName +
                  "' with a framework-generated bean definition: replacing [" +
                  oldBeanDefinition + "] with [" + beanDefinition + "]");
         }
      }
      else if (!beanDefinition.equals(oldBeanDefinition)) {
         if (this.logger.isInfoEnabled()) {
            this.logger.info("Overriding bean definition for bean '" + beanName +
                  "' with a different definition: replacing [" + oldBeanDefinition +
                  "] with [" + beanDefinition + "]");
         }
      }
      else {
         if (this.logger.isDebugEnabled()) {
            this.logger.debug("Overriding bean definition for bean '" + beanName +
                  "' with an equivalent definition: replacing [" + oldBeanDefinition +
                  "] with [" + beanDefinition + "]");
         }
      }
      // 记录到bean map中
      this.beanDefinitionMap.put(beanName, beanDefinition);
   }
   else {
      // 如果有其他的bean正在创建，那么加锁同步
      if (hasBeanCreationStarted()) {
         // Cannot modify startup-time collection elements anymore (for stable iteration)
         synchronized (this.beanDefinitionMap) {
            this.beanDefinitionMap.put(beanName, beanDefinition);
            List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);
            updatedDefinitions.addAll(this.beanDefinitionNames);
            updatedDefinitions.add(beanName);
            this.beanDefinitionNames = updatedDefinitions;
            // 如果此bean是手动创建的bean
            if (this.manualSingletonNames.contains(beanName)) {
               Set<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);
               updatedSingletons.remove(beanName);
               this.manualSingletonNames = updatedSingletons;
            }
         }
      }
      else {
         // Still in startup registration phase
         this.beanDefinitionMap.put(beanName, beanDefinition);
         this.beanDefinitionNames.add(beanName);
         this.manualSingletonNames.remove(beanName);
      }
      this.frozenBeanDefinitionNames = null;
   }
   // 重置bean缓存 
   if (oldBeanDefinition != null || containsSingleton(beanName)) {
      resetBeanDefinition(beanName);
   }
}
```

上面的代码我们可以看到，在对于bean的注册处理方式上，主要进行了几个步骤：

1. 对AbstractBeanDefinition的校验
2. 对beanName已经注册了情况下，如果设置了不允许覆盖bean，则需要抛出异常，否则直接覆盖并记录日志
3. 如果beanName未注册，此时有其他bean正在创建的过程中，因为beanDefinitionMap是全局变量，存在并发访问，需要对其加锁处理
4. 没有其他bean正在创建，则直接加入map中
5. 清除解析前留下的对应beanName的缓存

下面代码就是步骤一的处理过程，逻辑很清晰

```
public void validate() throws BeanDefinitionValidationException {
   // 如果同时使用方法注入和工厂方法，抛出异常
   if (!getMethodOverrides().isEmpty() && getFactoryMethodName() != null) {
      throw new BeanDefinitionValidationException(
            "Cannot combine static factory method with method overrides: " +
            "the static factory method must create the instance");
   }

   // 进行预处理
   if (hasBeanClass()) {
      prepareMethodOverrides();
   }
}

public void prepareMethodOverrides() throws BeanDefinitionValidationException {
   // Check that lookup methods exists.
   MethodOverrides methodOverrides = getMethodOverrides();
   // 如果使用了方法注入，对它进行预处理
   if (!methodOverrides.isEmpty()) {
      Set<MethodOverride> overrides = methodOverrides.getOverrides();
      synchronized (overrides) {
         for (MethodOverride mo : overrides) {
            prepareMethodOverride(mo);
         }
      }
   }
}

protected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException {
   // 检查是否存在此方法
   int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());
   if (count == 0) {
      throw new BeanDefinitionValidationException(
            "Invalid method override: no method with name '" + mo.getMethodName() +
            "' on class [" + getBeanClassName() + "]");
   }
   // 如果没有重载这个方法，标记它为非重载，避免参数类型检查
   else if (count == 1) {
      // Mark override as not overloaded, to avoid the overhead of arg type checking.
      mo.setOverloaded(false);
   }
}
```

#### 1.4.2. 通过别名注册BeanDefinition

在理解了注册bean的原理后，理解注册别名的原理就容易多了

```
// Register aliases for bean name, if any.
String[] aliases = definitionHolder.getAliases();
if (aliases != null) {
   for (String alias : aliases) {
      registry.registerAlias(beanName, alias);
   }
}

#class GenericApplicationContext
@Override
public void registerAlias(String beanName, String alias) {
   this.beanFactory.registerAlias(beanName, alias);
}

public void registerAlias(String name, String alias) {
   Assert.hasText(name, "'name' must not be empty");
   Assert.hasText(alias, "'alias' must not be empty");
   // 如果别名与id相同，略过
   if (alias.equals(name)) {
      this.aliasMap.remove(alias);
   }
   else {
      String registeredName = this.aliasMap.get(alias);
      // 检查此别名是否已经被注册过
      if (registeredName != null) {
         // 如果已经为这个bean注册过这个别名，直接返回
         if (registeredName.equals(name)) {
            // An existing alias - no need to re-register
            return;
         }
         // 如果这个别名已经为其他bean注册过，并且不允许覆盖，抛出异常
         if (!allowAliasOverriding()) {
            throw new IllegalStateException("Cannot register alias '" + alias + "' for name '" +
                  name + "': It is already registered for name '" + registeredName + "'.");
         }
      }
      // 检查别名的循环引用
      checkForAliasCircle(name, alias);
      // 记录到别名表中
      this.aliasMap.put(alias, name);
   }
}

// 默认允许别名覆盖
protected boolean allowAliasOverriding() {
   return true;
}

protected void checkForAliasCircle(String name, String alias) {
   // 注意此处name，alias调换
   if (hasAlias(alias, name)) {
      throw new IllegalStateException("Cannot register alias '" + alias +
            "' for name '" + name + "': Circular reference - '" +
            name + "' is a direct or indirect alias for '" + alias + "' already");
   }
}

public boolean hasAlias(String name, String alias) {
   for (Map.Entry<String, String> entry : this.aliasMap.entrySet()) {
      String registeredName = entry.getValue();
      if (registeredName.equals(name)) {
         String registeredAlias = entry.getKey();
         return (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias));
      }
   }
   return false;
}
```

从以上代码可以得知注册alias的步骤如下：

1. alias与beanName相同情况处理。若名称相同则不需要处理并删除原有alias
2. 如果alias已经注册过并且指向的beanName和此beanName相同，则直接返回无需再次注册
3. alias覆盖处理。若aliasNme已经使用并指向另一个beanName，则需要用户的设置进行处理
4. alias循环检查。当A->B存在时，若再次出现B->A的时候会抛出异常。
5. 注册alias

### 1.5 通知监视器解析及注册完成

通过代码`getReaderContext().fireComponentRegistered(newBeanComponentDefinition(bdHolder))`完成此工作，这里的实现只为拓展，当程序开发人员需要对注册`BeanDefinition`事件进行监听时可以通过注册监听器的方式并将处理逻辑写入监听器中，目前在Spring中并没有对此事件做任何逻辑处理。

```
getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));

#class ReaderContext
public void fireComponentRegistered(ComponentDefinition componentDefinition) {
   this.eventListener.componentRegistered(componentDefinition);
}

#class EmptyReaderEventListener
@Override
public void componentRegistered(ComponentDefinition componentDefinition) {
   // no-op
}
```
## 2. alias标签的解析

在对bean进行定义时，除了使用id和name属性来指定名称外，为了提供多个名称，还可以使用alias标签来指定。而所有的这些名称都指向同一个bean，在某些情况下提供别名非常有用。

然而，在定义bean时就指定所有的别名并不是总是恰当的。有时我们期望能在当前位置为那些在别处定义的bean引入别名。在xml文件中，可用单独的`<alias />`元素来完成bean别名的定义。如在配置文件中定义一个javaBean：

```
<bean id=”testBean” class=”conm.test.Test” />
```

要给这个javaBean增加别名，以方便不同对象来使用。我们可以直接使用bean标签中的name属性：

```
<bean id=”testBean” name=”testBean2” class=”conm.test.Test” />
```

同样，Spring还有另一种声明别名的方式:

```
<alias name=”testBean” alias=”testBean2” />
```

现在我们来深入分析下对于alias标签的解析过程

```
protected void processAliasRegistration(Element ele) {
   // 获取name属性
   String name = ele.getAttribute(NAME_ATTRIBUTE);
   // 获取alias属性
   String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
   // 验证标签的合法性
   boolean valid = true;
   if (!StringUtils.hasText(name)) {
      getReaderContext().error("Name must not be empty", ele);
      valid = false;
   }
   if (!StringUtils.hasText(alias)) {
      getReaderContext().error("Alias must not be empty", ele);
      valid = false;
   }
   if (valid) {
      try {
         getReaderContext().getRegistry().registerAlias(name, alias);
      }
      catch (Exception ex) {
         getReaderContext().error("Failed to register alias '" + alias +
               "' for bean with name '" + name + "'", ele, ex);
      }
      getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
   }
}
```

与之前bean中的alias解析过程一样，都是将beanName与别名注册到registry中。同时，最后一句`getReaderContext().fireAliasRegistered(name, alias, extractSource(ele))`也如前面一样，是一个空实现。

> 注：alias标签内的name，alias为一对一关系，不能在alias中使用分隔符同时创建多个别名

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop 
       http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="hello" class="common.Hello">
        <property name="message" value="hello world!" />
    <bean/>

    <alias name="hello" alias="hello4,hello5" />
</beans>
```
```
@Test
public void testAlias() {
    BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("spring-config.xml"));
    Hello hello = (Hello) beanFactory.getBean("hello4");
    hello.print();
}
```
输出结果：
```
org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'hello4' available
```

```
@Test
public void testAlias() {
    BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("spring-config.xml"));
    Hello hello = (Hello) beanFactory.getBean("hello4,hello5");
    hello.print();
}
```

输出结果：
```
Your message: hello world!
```

## 3. import标签的解析

```
<import resource=”……” />
```

```
protected void importBeanDefinitionResource(Element ele) {
   // 获取resources属性
   String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
   if (!StringUtils.hasText(location)) {
      getReaderContext().error("Resource location must not be empty", ele);
      return;
   }

   // 解析系统属性，例如"${user.dir}"
   location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

   Set<Resource> actualResources = new LinkedHashSet<Resource>(4);

   // 检测路径是绝对还是相对URI
   boolean absoluteLocation = false;
   try {
       // 或者classpath*或classpath开头，或者是一个标准URL，或者是一个绝对URI
       // 满足一个条件即是绝对路径
      absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
   }
   catch (URISyntaxException ex) {
      // cannot convert to an URI, considering the location relative
      // unless it is the well-known Spring prefix "classpath*:"
   }

   // 如果是绝对路径，直接加载这个配置文件
   if (absoluteLocation) {
      try {
         // 最终还是调用了刚开始提及的解析XML配置文件的方法
         int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
         if (logger.isDebugEnabled()) {
            logger.debug("Imported " + importCount + " bean definitions from URL location [" + location + "]");
         }
      }
      catch (BeanDefinitionStoreException ex) {
         getReaderContext().error(
               "Failed to import bean definitions from URL location [" + location + "]", ele, ex);
      }
   }
   else {
      // No URL -> considering resource location as relative to the current file.
      try {
         int importCount;
         // 根据当前上下文中的Resource构建相对路径
         Resource relativeResource = getReaderContext().getResource().createRelative(location);
         // 如果能找到这个配置文件，解析它
         if (relativeResource.exists()) {
            importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
            actualResources.add(relativeResource);
         }
         // 如果解析不成功，则使用默认的解析器ResourcePattrenResolver进行解析
         else {
            String baseLocation = getReaderContext().getResource().getURL().toString();
            importCount = getReaderContext().getReader().loadBeanDefinitions(
                  StringUtils.applyRelativePath(baseLocation, location), actualResources);
         }
         if (logger.isDebugEnabled()) {
            logger.debug("Imported " + importCount + " bean definitions from relative location [" + location + "]");
         }
      }
      catch (IOException ex) {
         getReaderContext().error("Failed to resolve current resource location", ele, ex);
      }
      catch (BeanDefinitionStoreException ex) {
         getReaderContext().error("Failed to import bean definitions from relative location [" + location + "]",
               ele, ex);
      }
   }
   // 解析后进行监听器激活处理，如前面一样，是一个空实现
   Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]);
   getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
}
```

上述的代码并不难，相信配合注释很好理解，我们总结一下大致流程：

1. 获取resource属性所表示的路径
2. 解析路径中的系统属性，格式如${user.dir}
3. 判断location是绝对路径还是相对路径
4. 如果是绝对路径则递归调用bean的解析过程，进行另一次解析
5. 如果是相对路径则计算出绝对路径并进行解析
6. 通知监听器，解析完成

## 4. 嵌入式beans标签的解析

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop 
       http://www.springframework.org/schema/aop/spring-aop.xsd">

    <beans>
    </beans>

</beans>

```

对于嵌入式beans标签来说没有太多可讲，无非是递归调用beans的解析过程 。

```
protected void doRegisterBeanDefinitions(Element root) {
   // Any nested <beans> elements will cause recursion in this method. In
   // order to propagate and preserve <beans> default-* attributes correctly,
   // keep track of the current (parent) delegate, which may be null. Create
   // the new (child) delegate with a reference to the parent for fallback purposes,
   // then ultimately reset this.delegate back to its original (parent) reference.
   // this behavior emulates a stack of delegates without actually necessitating one.
   BeanDefinitionParserDelegate parent = this.delegate;
   this.delegate = createDelegate(getReaderContext(), root, parent);

   if (this.delegate.isDefaultNamespace(root)) {
      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
      if (StringUtils.hasText(profileSpec)) {
         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
         if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
            if (logger.isInfoEnabled()) {
               logger.info("Skipped XML bean definition file due to specified profiles [" + profileSpec +
                     "] not matching: " + getReaderContext().getResource());
            }
            return;
         }
      }
   }

   preProcessXml(root);
   parseBeanDefinitions(root, this.delegate);
   postProcessXml(root);

   this.delegate = parent;
}
```

## 总结

```
parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate); 解析默认空间标签
    processBeanDefinition(ele, delegate); 解析bean标签
        delegate.parseBeanDefinitionElement(ele); 进行元素解析，返回BeanDifinitionHolder
            ele.getAttribute(ID_ATTRIBUTE); 解析id属性
            ele.getAttribute(NAME_ATTRIBUTE); 解析name属性
            StringUtils.tokenizeToStringArray(nameAttr, ",; "); 解析alias别名
            如果未指定id属性，选取一个别名作为id
            checkNameUniqueness(beanName, aliases, ele); 检查id以及别名是否被注册过
                this.usedNames.contains(beanName);  检查id是否已被注册
                CollectionUtils.findFirstMatch(this.usedNames, aliases); 检查别名是否已被注册
                this.usedNames.add(beanName); 记录id以及别名
                this.usedNames.addAll(aliases);
            parseBeanDefinitionElement(ele, beanName, containingBean); 解析bean标签元素
                ele.getAttribute(CLASS_ATTRIBUTE).trim(); 解析class属性
                ele.getAttribute(PARENT_ATTRIBUTE); 解析parent属性
                createBeanDefinition(className, parent); 创建BeanDefinition保存配置信息
                parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); 硬编码解析bean的各种属性
                    ele.hasAttribute(SINGLETON_ATTRIBUTE) 禁止使用singleton属性
                    bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));  解析并记录scope属性	
                    bd.setScope(containingBean.getScope()); 未指定scope尝试解析外部bean scope		
                    ele.hasAttribute(ABSTRACT_ATTRIBUTE) 解析abstrct属性
                    ele.getAttribute(LAZY_INIT_ATTRIBUTE); 解析lazy-init属性
                    ele.getAttribute(AUTOWIRE_ATTRIBUTE); 解析autwire属性
                    ele.getAttribute(DEPENDENCY_CHECK_ATTRIBUTE); 解析dependency-check属性
                    ele.getAttribute(DEPENDS_ON_ATTRIBUTE); 解析depends-on属性
                    ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE); 解析autowire-candidate属性
                    ele.hasAttribute(PRIMARY_ATTRIBUTE) 解析primary属性
                    ele.hasAttribute(INIT_METHOD_ATTRIBUTE) 解析init-method属性
                    ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE) 解析destroy-method属性
                    ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE) 解析factory-method属性
                    ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE) 解析factor-bean属性
                bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); 解析description元素
                parseMetaElements(ele, bd); 解析meta元数据
                parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); 解析lookup-method
                parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); 解析replaced-method
                parseConstructorArgElements(ele, bd); 解析constructor-arg子元素
                    ele.getAttribute(INDEX_ATTRIBUTE); 解析index属性
                    ele.getAttribute(TYPE_ATTRIBUTE); 解析type属性
                    ele.getAttribute(NAME_ATTRIBUTE); 解析name属性
                    if (StringUtils.hasLength(indexAttr)) 如果指定了index属性
                        Integer.parseInt(indexAttr); 将字符串解析为int
                        parsePropertyValue(ele, bd, null); 解析其他属性以及子元素
                            解析子元素，略过meta以及description子元素
                            ele.hasAttribute(REF_ATTRIBUTE); 解析ref属性
                            ele.hasAttribute(VALUE_ATTRIBUTE); 解析value属性
                            验证：子元素，ref属性，value属性只能存在一个
                            new RuntimeBeanReference(ele.getAttribute(REF_ATTRIBUTE)); 记录ref属性或者
                            TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); 记录value属性或者
                            parsePropertySubElement(subElement, bd); 解析子元素信息，下面只能存在一个
                                !isDefaultNamespace(ele) 如果子元素不属于默认命名空间
                                parseNestedCustomElement(ele, bd); 解析嵌套的自定义元素
                                parseBeanDefinitionElement(ele, bd); 解析<bean>子元素
                                nodeNameEquals(ele, REF_ELEMENT) 解析ref子元素
                                parseIdRefElement(ele); 解析idref子元素
                                parseValueElement(ele, defaultValueType); 解析value子元素
                                nodeNameEquals(ele, NULL_ELEMENT) 解析<null/>子元素
                                parseArrayElement(ele, bd); 解析array子元素
                                parseListElement(ele, bd); 解析list子元素
                                parseSetElement(ele, bd); 解析set子元素
                                parseMapElement(ele, bd); 解析map子元素
                                parsePropsElement(ele); 解析props子元素
                        addIndexedArgumentValue(index, valueHolder); 封装各种信息并记录到BeanDefinition中
                    未指定index属性
                        parsePropertyValue(ele, bd, null);
                        addGenericArgumentValue(valueHolder); 封装各种信息并记录到BeanDefinition中
                parsePropertyElements(ele, bd); 解析property子元素
                    ele.getAttribute(NAME_ATTRIBUTE); 解析name属性
                    parsePropertyValue(ele, bd, propertyName); 解析其他属性以及子元素
                    parseMetaElements(ele, pv); 解析meta元素
                    addPropertyValue(pv); 保存到BeanDefinition中
                parseQualifierElements(ele, bd); 解析qualify子元素
                    ele.getAttribute(TYPE_ATTRIBUTE); 解析type属性
                    ele.getAttribute(VALUE_ATTRIBUTE); 解析value属性
                    解析attribute子元素
                    addQualifier(qualifier); 保存到BeanDefinition中
		delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); 如果bean标签内存在自定义标签，解析它
                    decorateIfRequired(node, finalDefinition, containingBd); 如果存在自定义属性或者自定义子元素
                        getNamespaceURI(node); 获取命名空间
                        getNamespaceHandlerResolver().resolve(namespaceUri); 根据用户提供的NamespaceHandler处理
                        handler.decorate(node, ...);
		registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); 注册bean定义
                    registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); 通过id注册
                        ((AbstractBeanDefinition) beanDefinition).validate(); 验证bean合法性，方法注入和factory方法不能同时存在
                        如果已存在此bean，允许覆盖则覆盖
                        否则，直接加入到map中
                    registerAlias(beanName, alias); 通过别名注册
                        如果别名已被注册，覆盖
                        checkForAliasCircle(name, alias); 检查别名循环引用
                        this.aliasMap.put(alias, name); 加入别名表中
		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); 发布注册事件，空实现
	processAliasRegistration(ele); 解析alias标签
            ele.getAttribute(NAME_ATTRIBUTE); 解析name属性
            ele.getAttribute(ALIAS_ATTRIBUTE); 解析alias属性
            registerAlias(name, alias); 注册别名
            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); 发布注册事件，空实现
	importBeanDefinitionResource(ele); 解析import标签
            ele.getAttribute(RESOURCE_ATTRIBUTE); 解析resources属性
            resolveRequiredPlaceholders(location); 解析系统属性[占位符]
            ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); 判断是绝对路径还是相对路径
            loadBeanDefinitions(location, actualResources); 加载配置文件
            getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele)); 发布注册事件，空实现
	doRegisterBeanDefinitions(ele); 解析beans标签，与前面调用的是一个方法，从profile开始解析
```
