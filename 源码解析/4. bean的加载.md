bean的加载的功能实现远比bean的解析复杂的多，同样我们还是以开篇的示例为基础，对于加载bean的功能，在Spring中调用的方式为：
```
Hello hello = (Hello) beanFactory.getBean(**"hello"**);
```

这句代码实现了什么样的功能？我们先快速体验一下Spring中代码是如何实现的。

```
@Override
public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}

protected <T> T doGetBean(
      final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)
      throws BeansException {

   // 转换bean名称
   final String beanName = transformedBeanName(name);
   Object bean;

   // Eagerly check singleton cache for manually registered singletons.
   // 尝试从缓存中获取单例
   Object sharedInstance = getSingleton(beanName);
   if (sharedInstance != null && args == null) {
      if (logger.isDebugEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.debug("Returning eagerly cached instance of singleton bean '" + beanName +
                  "' that is not fully initialized yet - a consequence of a circular reference");
         }
         else {
            logger.debug("Returning cached instance of singleton bean '" + beanName + "'");
         }
      }
      // 返回对应的实例，如果这个bean为BeanFactory，那么不是直接返回bean实例而是返回工厂方法创建的实例
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }

   else {
      // Fail if we're already creating this bean instance:
      // We're assumably within a circular reference.
      // protptype模式不支持循环引用
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }

      // Check if bean definition exists in this factory.
      // 检查是否存在父bean工厂，用于容器继承体系中
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
         // Not found -> check parent.
         String nameToLookup = originalBeanName(name);
         if (args != null) {
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else {
            // No args -> delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
      }

      // 获取bean的方法默认此参数为false
      if (!typeCheckOnly) {
         markBeanAsCreated(beanName);
      }

      try {
         // 合并父bean中的信息
         final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
         checkMergedBeanDefinition(mbd, beanName, args);

         // Guarantee initialization of beans that the current bean depends on.
         // 检查是否设置了depends-on属性，如果设置了，先加载依赖的bean
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
               }
               registerDependentBean(dep, beanName);
               getBean(dep);
            }
         }

         // Create bean instance.
         // 如果这个bean是单例
         if (mbd.isSingleton()) {
            sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
               @Override
               public Object getObject() throws BeansException {
                  try {
                     return createBean(beanName, mbd, args);
                  }
                  catch (BeansException ex) {
                     // Explicitly remove instance from singleton cache: It might have been put there
                     // eagerly by the creation process, to allow for circular reference resolution.
                     // Also remove any beans that received a temporary reference to the bean.
                     destroySingleton(beanName);
                     throw ex;
                  }
               }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }

         // 如果这个bean是原型
         else if (mbd.isPrototype()) {
            // It's a prototype -> create a new instance.
            Object prototypeInstance = null;
            try {
               beforePrototypeCreation(beanName);
               prototypeInstance = createBean(beanName, mbd, args);
            }
            finally {
               afterPrototypeCreation(beanName);
            }
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }

         // 其他作用域的bean
         else {
            String scopeName = mbd.getScope();
            final Scope scope = this.scopes.get(scopeName);
            if (scope == null) {
               throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
            }
            try {
               Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {
                  @Override
                  public Object getObject() throws BeansException {
                     beforePrototypeCreation(beanName);
                     try {
                        return createBean(beanName, mbd, args);
                     }
                     finally {
                        afterPrototypeCreation(beanName);
                     }
                  }
               });
               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
            }
            catch (IllegalStateException ex) {
               throw new BeanCreationException(beanName,
                     "Scope '" + scopeName + "' is not active for the current thread; consider " +
                     "defining a scoped proxy for this bean if you intend to refer to it from a singleton",
                     ex);
            }
         }
      }
      catch (BeansException ex) {
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
   }

   // Check if required type matches the type of the actual bean instance.
   // 检查调用getBean方法指定的类型是否和这个bean的实际类型匹配
   // 如果不匹配就尝试对其进行类型转换
   if (requiredType != null && bean != null && !requiredType.isInstance(bean)) {
      try {
         return getTypeConverter().convertIfNecessary(bean, requiredType);
      }
      catch (TypeMismatchException ex) {
         if (logger.isDebugEnabled()) {
            logger.debug("Failed to convert bean '" + name + "' to required type '" +
                  ClassUtils.getQualifiedName(requiredType) + "'", ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
   return (T) bean;
}
```

从代码量上能看出来bean的加载经历了一个相当复杂的过程，其中涉及各种各样的考虑。对于加载过程所涉及的步骤大致如下：

1. 转换对应的beanName
或许不理解转换对应的beanName是什么意思，传入的参数name可能是别名，也可能是`FactoryBean`，所以需要进行一系列的解析，解析内容包括如下内容：
a. 去除`FactoryBean`的修饰符，也就是如果name=”&aa”，那么首先会去除&得到name=”aa”
b. 取指定alias所表示的最终beanName，例如别名A指向名称为B的bean则会返回B

2. 尝试从缓存中加载单例
单例在Spring的同一个容器内只会创建一次，后续再次请求获取此bean时，就直接从单例缓存中获取了。当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功再尝试从singletionFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，在Spring中创建bean的原则是不等bean创建完成就会将创建bean的`ObjectFactory`提早曝光加载到缓存中，一旦下一个bean创建时候需要依赖上一个bean则直接使用`ObjectFactory`（后续会对循环依赖具体讲解）

3. bean的实例化
如果从缓存中得到了bean的原始状态，则需要对bean进行实例化。这里有必要强调一下，缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean。举个例子，假如我们想对`FactoryBean`进行处理，那么这里得到的其实是`FactoryBean`的初始状态，但是我们真正需要的是`FactoryBean`中定义的`factory-method`方法中返回的bean，而`getObjectForBeanInstance`就是完成这个工作的。

4. 原型模式的依赖检查
只有在单例情况下才会尝试解决循环依赖，如果存在循环依赖，也就是`isPrototypeCurrentlyInCreation(beanName)`为true，则会抛出异常

5. 检测parentBeanFactory
从代码上看，如果缓存没有数据的话直接转到父类工厂上去加载了，这是为什么呢？
有一个很重要的判断条件`parentBeanFactory != **null**&& !containsBeanDefinition(beanName)`。如果`parentBeanFactory`为空，那么一切都是浮云，这个没什么好说的，但是`!containsBeanDefinition(beanName)`就很重要了，如果当前加载xml配置文件中不包含beanName所对应的配置，那么只能到`parentBeanFactory`中去尝试了，然后再去递归的调用`getBean`方法

6. 将存储xml配置文件的GenericBeanDefinition转换为RootBeanDefinition
因为从xml配置文件中读取的信息是保存到`GenericBeanDefinition`中的，但是所有bean的后续处理都是针对于`RootBeanDefinition`的，所有这里需要一个转换，转换的同时如果父类不为空的话，则会合并父类的属性

7. 寻找依赖
bean的初始化可能会用到某些属性，而某些属性可能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖

8. 针对不同的scope进行bean的创建
Spring中存在不同的scope，其中默认的是singleton，但是还有些其他的配置注入protoype，request之类的。在这个配置中，Spring会根据不同的配置进行不同的初始化策略

9. 类型转换
程序到这里返回bean就已经基本结束了，通常对该方法的调用参数`requiredType`是空的，但是可能会存在这样的情况，返回的bean其实是个String，但是requiredType却传入Integet类型，那么本步骤就会起作用了，当然String转换为Integer是最简单的一种转换，在Spring中存在各种各样的转换器，用户也可以自己拓展转换器来满足需求。

在细化分析各个步骤的情况前，我们首先需要了解下`FactoryBean`的用法。

## 1. FactoryBean的使用

一般情况下，Spring通过反射机制利用bean的class属性指定的实际类来实例化bean。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在`<bean />`中提供大量的配置信息，配置方式的灵活方式是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个`FactoryBean`的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。

`FactoryBean`接口对于Spring框架来说占有重要的地位，Spring本身就提供了70多个`FactoryBean`的实现。他们隐藏了实例化一些复杂的bean的细节，给上层应用提供了便利。

```
public interface FactoryBean<T> {
      T getObject() throws Exception;
      Class<?> getObjectType();
      boolean isSingleton();
}
```

当配置文件中`<bean />`的class属性配置的实现类是`FactoryBean`时，通过`getBean`方法返回的不是`FactoryBean`本身，而是`FactoryBean#getObject()`方法所返回的对象，相当于`FactoryBean#getObject()`代理了`getBean()`方法。关于`FactoryBean`的更多信息，查看[1.8.3. Customizing Instantiation Logic with a FactoryBean](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-factorybean)。

## 2. 缓存中获取单例bean

介绍过`FactoryBean`的用法后，我们就可以了解bean加载的过程了。前面已经提到过，单例在Spring的同一个容器内只会创建一次，后续在获取bean直接从单例缓存中获取，当然这里也只是尝试加载。

步骤一beanName名称转换的代码如下：

```
protected String transformedBeanName(String name) {
   return canonicalName(BeanFactoryUtils.transformedBeanName(name));
}

public static String transformedBeanName(String name) {
   Assert.notNull(name, "'name' must not be null");
   String beanName = name;
   // String FACTORY_BEAN_PREFIX = "&";  如果名称以&开头，则去除
   while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {
      beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());
   }
   return beanName;
}

public String canonicalName(String name) {
   String canonicalName = name;
   // 处理别名
   String resolvedName;
   do {
      // 尝试从别名表中查找此名称
      resolvedName = this.aliasMap.get(canonicalName);
      if (resolvedName != null) {
         canonicalName = resolvedName;
      }
   }
   while (resolvedName != null);
   return canonicalName;
}
```

获取beanName后接下来进入从缓存中获取单例bean的代码：

```
@Override
public Object getSingleton(String beanName) {
   // 参数true表示允许循环引用
   return getSingleton(beanName, true);
}

protected Object getSingleton(String beanName, boolean allowEarlyReference) {
   // 检查缓存中是否存在此bean
   Object singletonObject = this.singletonObjects.get(beanName);
   // 如果缓存中没有，则检查此bean是否正在创建
   if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
      // 同步控制
      synchronized (this.singletonObjects) {
         singletonObject = this.earlySingletonObjects.get(beanName);
         // 如果，并且允许循环引用
         if (singletonObject == null && allowEarlyReference) {
            // 尝试获取单例工厂方法，当此bean在创建时会将工厂方法暴露出来，所以此时能获取到
            // 根据这种方法来解决循环引用的问题
            ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
            if (singletonFactory != null) {
               // 调用工厂方法的getObject()方法获取此单例
               singletonObject = singletonFactory.getObject();
               // 置于缓存中
               this.earlySingletonObjects.put(beanName, singletonObject);
               // 如果再请求这个bean，则可以直接从上面的缓存中获取，因此单例工厂没有存在的必要了
               this.singletonFactories.remove(beanName);
            }
         }
      }
   }
   return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```


这个方法因为涉及到循环依赖的检测，以及涉及到很多变量的记录存取，所以让人摸不着头脑。这个方法首先尝试从`singletonObjects`里面获取实例，如果获取不到再从`earlySingletonObjects`中获取，如果还获取不到，再尝试从`singletionFactories`中获取beanName对应的`ObjectFactory`，然后调用这个`ObjectFactory`的`getObject`来创建bean，并放到`earlySingletonObjects`中，然后从`singletonFactories`中删除掉这个`ObjectFactory`，对于后续所有的内存操作都只是为了循环依赖检测的时候使用，也就是在`allowEarlyReference`为true的情况下才会使用。

```
/** Cache of singleton objects: bean name --> bean instance */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);
/** Cache of singleton factories: bean name --> ObjectFactory */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);
/** Cache of early singleton objects: bean name --> bean instance */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);
```

## 3. 从bean的实例中获取对象

在`getBean`方法中，`getObjectForBeanInstance`是个高频率使用的方法，无论从缓存中获取bean还是根据不同的scope策略加载bean。总之，我们得到bean的实例后要做的第一步就是调用这个方法来检测一下正确性，其实就是用于检测当前bean是否是`FactoryBean`类型的bean，如果是，那么需要调用该bean对应的`FactoryBean`实例中的`getObject()`方法作为返回值。

如果从缓存中得到了bean的原始状态，则需要对bean进行实例化。这里有必要强调一下，缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean。举个例子，假如我们想对`FactoryBean`进行处理，那么这里得到的其实是`FactoryBean`的初始状态，但是我们真正需要的是`FactoryBean`中定义的`factory-method`方法中返回的bean，而`getObjectForBeanInstance`就是完成这个工作的。

```
protected Object getObjectForBeanInstance(
      Object beanInstance, String name, String beanName, RootBeanDefinition mbd) {

   // Don't let calling code try to dereference the factory if the bean isn't a factory.
   // 如果在beanName中使用&请求一个FactoryBean，但是这个bean本身不是FactoryBean，则抛出异常
   if (BeanFactoryUtils.isFactoryDereference(name) && !(beanInstance instanceof FactoryBean)) {
      throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());
   }

   // Now we have the bean instance, which may be a normal bean or a FactoryBean.
   // If it's a FactoryBean, we use it to create a bean instance, unless the
   // caller actually wants a reference to the factory.
   // 如果这个bean是一个常规bean或者
   // 这个bean是一个FactoryBean并且getBean方法使用&请求了一个FactoryBean
   // 那么直接返回这个实例即可
   if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
      return beanInstance;
   }

   // 到此步后，已经可以确定此bean是一个FactoryBean，并且getBean方法请求
   // 获取FactoryBean创建的实例而不是FactoryBean本身
   Object object = null;
   if (mbd == null) {
      // 尝试从缓存中获取
      object = getCachedObjectForFactoryBean(beanName);
   }
   // 如果缓存中不存在，即第一次请求这个bean实例
   if (object == null) {
      // Return bean instance from factory.
      // 因为可以确定它是FactoryBean，所以可以安全进行类型转换
      FactoryBean<?> factory = (FactoryBean<?>) beanInstance;
      // Caches object obtained from FactoryBean if it is a singleton.
      // 尝试从缓存中获取这个bean的元数据
      if (mbd == null && containsBeanDefinition(beanName)) {
         // 将存储xml配置文件的GenericBeanDefinition转换为RootBeanDefinition，
         // 如果指定的beanName是子bean，则需要合并父bean的属性
         mbd = getMergedLocalBeanDefinition(beanName);
      }
      // 查看这个bean是否是编译器生成的
      boolean synthetic = (mbd != null && mbd.isSynthetic());
      // 调用FactoryBean的getObject方法创建实例
      object = getObjectFromFactoryBean(factory, beanName, !synthetic);
   }
   return object;
}

// 尝试从缓存中获取FactoryBean
protected Object getCachedObjectForFactoryBean(String beanName) {
   Object object = this.factoryBeanObjectCache.get(beanName);
   return (object != NULL_OBJECT ? object : null);
}

// 获取这个bean的元数据
protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {
   // Quick check on the concurrent map first, with minimal locking.
   // 首先快速检查缓存表中是否存在这个bean，如果有直接返回
   RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);
   if (mbd != null) {
      return mbd;
   }
   return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
}

protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd)
      throws BeanDefinitionStoreException {

   return getMergedBeanDefinition(beanName, bd, null);
}

protected RootBeanDefinition getMergedBeanDefinition(
      String beanName, BeanDefinition bd, BeanDefinition containingBd)
      throws BeanDefinitionStoreException {

   // 对缓存表加锁，保证多线程下的数据一致性
   synchronized (this.mergedBeanDefinitions) {
      RootBeanDefinition mbd = null;

      // Check with full lock now in order to enforce the same merged instance.
      // 加锁后再次检查缓存表，因为前面检查缓存表后可能有其他线程将它加入到表中
      // 这样做的原因是为了多线程环境下的性能优化
      if (containingBd == null) {
         mbd = this.mergedBeanDefinitions.get(beanName);
      }

      if (mbd == null) {
         // 如果没有父bean
         if (bd.getParentName() == null) {
            // Use copy of given root bean definition.
            // 使用给定root bean definition的拷贝或者新构建一个root bean definition的实例
            // 注意，在前面XML配置文件的解析过程中，一般使用GenericBeanDefinition来保存bean的元数据
            if (bd instanceof RootBeanDefinition) {
               mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
            }
            else {
               mbd = new RootBeanDefinition(bd);
            }
         }
         // 如果存在父bean
         else {
            // Child bean definition: needs to be merged with parent.
            BeanDefinition pbd;
            try {
               // 转换父bean的名称
               String parentBeanName = transformedBeanName(bd.getParentName());
               if (!beanName.equals(parentBeanName)) {
                  // 获取保存父bean元信息的BeanDefinition
                  pbd = getMergedBeanDefinition(parentBeanName);
               }
               else {
                  // 尝试从父bean工厂中获取父bean
                  BeanFactory parent = getParentBeanFactory();
                  if (parent instanceof ConfigurableBeanFactory) {
                     pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);
                  }
                  // 如果还是找不到父bean，则抛出异常
                  else {
                     throw new NoSuchBeanDefinitionException(parentBeanName,
                           "Parent name '" + parentBeanName + "' is equal to bean name '" + beanName +
                           "': cannot be resolved without an AbstractBeanFactory parent");
                  }
               }
            }
            catch (NoSuchBeanDefinitionException ex) {
               throw new BeanDefinitionStoreException(bd.getResourceDescription(), beanName,
                     "Could not resolve parent bean definition '" + bd.getParentName() + "'", ex);
            }
            // Deep copy with overridden values.
            // 合并父bean以及子bean中的信息
            mbd = new RootBeanDefinition(pbd);
            mbd.overrideFrom(bd);
         }

         // Set default singleton scope, if not configured before.
         // 如果此bean为配置scope属性，则使用默认的作用域singleton
         if (!StringUtils.hasLength(mbd.getScope())) {
            mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);
         }

         // A bean contained in a non-singleton bean cannot be a singleton itself.
         // Let's correct this on the fly here, since this might be the result of
         // parent-child merging for the outer bean, in which case the original inner bean
         // definition will not have inherited the merged outer bean's singleton status.
         // 如果此bean是一个内部bean，并且外部bean不是单例，则需要使用外部bean的scope
         if (containingBd != null && !containingBd.isSingleton() && mbd.isSingleton()) {
            mbd.setScope(containingBd.getScope());
         }

         // Cache the merged bean definition for the time being
         // (it might still get re-merged later on in order to pick up metadata changes)
         // 将这个bean的元数据记录到缓存中，isCacheBeanMetadata()方法默认返回true
         if (containingBd == null && isCacheBeanMetadata()) {
            this.mergedBeanDefinitions.put(beanName, mbd);
         }
      }

      return mbd;
   }
}
```

这个方法大部分是一些辅助代码以及一些功能性的判断，而真正的核心代码委托给了`getObjectFromFactoryBean`，我们来看看`getObjectForBeanInstance`所作的工作。

1. 对`FactoryBean`正确性的验证
2. 对非`FactoryBean`不做任何处理
3. 对bean进行转换
4. 将从`FactoryBean`中解析bean的工作委托给`getObjectFromFactoryBean`

```
protected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {
   // 如果这个FactoryBean是单例
   if (factory.isSingleton() && containsSingleton(beanName)) {
      synchronized (getSingletonMutex()) {
         // 尝试从缓存中获取
         Object object = this.factoryBeanObjectCache.get(beanName);
         if (object == null) {
            // 调用FactoryBean的getObject方法创建实例
            object = doGetObjectFromFactoryBean(factory, beanName);
            // Only post-process and store if not put there already during getObject() call above
            // (e.g. because of circular reference processing triggered by custom getBean calls)
            Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
            if (alreadyThere != null) {
               object = alreadyThere;
            }
            else {
               // 一般来说bean不会由编译器合成，所以shouldPostProcess通常都是为true，即需要调用后置处理器
               if (object != null && shouldPostProcess) {
                  try {
                     // 调用后置处理器
                     object = postProcessObjectFromFactoryBean(object, beanName);
                  }
                  catch (Throwable ex) {
                     throw new BeanCreationException(beanName,
                           "Post-processing of FactoryBean's singleton object failed", ex);
                  }
               }
               // 放入缓存中
               this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));
            }
         }
         return (object != NULL_OBJECT ? object : null);
      }
   }
   // 如果FactoryBean不是单例
   else {
       // 调用getObejct方法创建实例，因为prototype每次使用时都需要一个新的实例，所以不需要缓存
      Object object = doGetObjectFromFactoryBean(factory, beanName);
      // 调用后置处理器
      if (object != null && shouldPostProcess) {
         try {
            object = postProcessObjectFromFactoryBean(object, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(beanName, "Post-processing of FactoryBean's object failed", ex);
         }
      }
      return object;
   }
}
```

在上面的代码中我们还是没有看到想要看到的代码，这个方法做了两件事，如果返回的bean是单例的，那么就必须保证全局唯一，同时也因为是单例的，所以不必重复创建，可以使用缓存来提高性能，也就是说已经加载过就要记录下来以便于下次复用。第二件事就是获得object后并没有立刻返回，而是进行了一些后处理的操作。

```
private Object doGetObjectFromFactoryBean(final FactoryBean<?> factory, final String beanName)
      throws BeanCreationException {

   Object object;
   try {
      // 检查是否需要权限验证
      if (System.getSecurityManager() != null) {
         AccessControlContext acc = getAccessControlContext();
         try {
            object = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
               @Override
               public Object run() throws Exception {
                     // 调用FactoryBean的getObject()方法
                     return factory.getObject();
                  }
               }, acc);
         }
         catch (PrivilegedActionException pae) {
            throw pae.getException();
         }
      }
      else {
         object = factory.getObject();
      }
   }
   catch (FactoryBeanNotInitializedException ex) {
      throw new BeanCurrentlyInCreationException(beanName, ex.toString());
   }
   catch (Throwable ex) {
      throw new BeanCreationException(beanName, "FactoryBean threw exception on object creation", ex);
   }

   // Do not accept a null value for a FactoryBean that's not fully
   // initialized yet: Many FactoryBeans just return null then.
   // FactoryBean#getObject()方法不应当返回null值
   if (object == null && isSingletonCurrentlyInCreation(beanName)) {
      throw new BeanCurrentlyInCreationException(
            beanName, "FactoryBean which is currently in creation returned null from getObject");
   }
   return object;
}
```

在这段代码中我们终于看到了想要的代码，也就是`object=factory.getObject();`

接下来我们看下做后处理操作的代码干了什么：

```
// 默认实现是直接返回这个实例本身，但是这个方法是可以重写的，在子类中重写了此方法
protected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException {
   return object;
}

#class AbstractAutowireCapableBeanFactory
@Override
protected Object postProcessObjectFromFactoryBean(Object object, String beanName) {
   return applyBeanPostProcessorsAfterInitialization(object, beanName);
}

@Override
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   // 执行所有的后置处理器
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessAfterInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}
```

关于后置处理器，查看[1.8.1. Customizing Beans by Using a BeanPostProcessor](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp)获得更多信息。Spring中获取bean的规则中有这么一条：尽可能保证所有的bean初始化后都会调用注册的`BeanPostProcessor`的`postProcessAfterInitialization`方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。

![](https://upload-images.jianshu.io/upload_images/13068256-9d7ba1fa63c832e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 4. 获取单例

之前我们讲的是从缓存中获取单例的过程，那么，如果缓存中不存在已经加载的单例bean就需要从头开始bean的加载过程了，而Spring中使用`getSingleton`的重载方法实现bean的加载过程。

```
// 不允许原型bean存在循环引用
if (isPrototypeCurrentlyInCreation(beanName)) {
   throw new BeanCurrentlyInCreationException(beanName);
}

// Check if bean definition exists in this factory.
// 检查这个bean定义是否存在于父bean工厂中
BeanFactory parentBeanFactory = getParentBeanFactory();
if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
   // Not found -> check parent.
   String nameToLookup = originalBeanName(name);
   if (args != null) {
      // Delegation to parent with explicit args.
      return (T) parentBeanFactory.getBean(nameToLookup, args);
   }
   else {
      // No args -> delegate to standard getBean method.
      return parentBeanFactory.getBean(nameToLookup, requiredType);
   }
}

// typeCheckOnly默认为false，所以会将这个bean标记为已创建
// 此举主要是优化FactoryBean的缓存机制
if (!typeCheckOnly) {
   markBeanAsCreated(beanName);
}

try {
   // 此方法前面已经分析过，合并父bean与子bean的元信息
   final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
   // 检查这个bean是否指定了abstract属性，因为不允许创建abstract bean
   checkMergedBeanDefinition(mbd, beanName, args);

   // Guarantee initialization of beans that the current bean depends on.
   // 检查depends-on
   String[] dependsOn = mbd.getDependsOn();
   if (dependsOn != null) {
      for (String dep : dependsOn) {
         // bean与被依赖bean之间不能存在循环引用
         // 检查dependentBeanMap中beanName是否被dep所依赖
         if (isDependent(beanName, dep)) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
         }
         // 注册bean与依赖bean
         // dependentBeanMap存储 被依赖bean --> bean之间的映射关系
         // dependenciesForBeanMap存储  bean --> 被依赖bean之间的映射关系
         registerDependentBean(dep, beanName);
         // 实例化被依赖的bean，注意depends-on关系一般存在于单例中
         getBean(dep);
      }
   }
```

在进行bean的真正实例化之前，先进行了一些预处理：

1. 检查原型是否存在循环引用。查看[Dependency Resolution Process](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependency-resolution)获取更多信息。
2. 如果当前BeanFactory中不存在这个bean，查看父bean工厂中是否存在，当然只有存在容器继承时才应用这一项功能，从父bean工厂中获取bean也是调用`getBean`方法
3. 合并父bean与子bean的元信息，并检查这个bean是否为abstract，如果是，抛出异常
4. 检查是否指定了depends-on属性，如果指定了，先实例化被依赖的bean。注意，bean本身与被依赖的bean之间不能存在循环引用。查看[1.4.3. Using depends-on](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-dependson)获取更多信息。

下面是单例bean的实例化操作：
```
if (mbd.isSingleton()) {
   // 调用getSingleton的重载方法创建bean实例，注意第二个参数为单例工厂
   sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {
      @Override
      public Object getObject() throws BeansException {
         try {
            return createBean(beanName, mbd, args);
         }
         catch (BeansException ex) {
            // Explicitly remove instance from singleton cache: It might have been put there
            // eagerly by the creation process, to allow for circular reference resolution.
            // Also remove any beans that received a temporary reference to the bean.
            destroySingleton(beanName);
            throw ex;
         }
      }
   });
   // 从bean的实例中获取对象
   bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
```

```
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
   Assert.notNull(beanName, "'beanName' must not be null");
   synchronized (this.singletonObjects) {
      // 尝试从缓存中获取单例，多线程优化（如果已经有其他线程创建了这个单例）
      Object singletonObject = this.singletonObjects.get(beanName);
      if (singletonObject == null) {
         // 如果此单例正在被销毁，那么无法创建
         if (this.singletonsCurrentlyInDestruction) {
            throw new BeanCreationNotAllowedException(beanName,
                  "Singleton bean creation not allowed while singletons of this factory are in destruction " +
                  "(Do not request a bean from a BeanFactory in a destroy method implementation!)");
         }
         if (logger.isDebugEnabled()) {
            logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
         }
         // 创建前预处理
         beforeSingletonCreation(beanName);
         boolean newSingleton = false;
         boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
         if (recordSuppressedExceptions) {
            this.suppressedExceptions = new LinkedHashSet<Exception>();
         }
         // 调用工厂方法的getObject()方法创建bean，注意这个工厂方法是由getSingleton第二个参数传入的
         try {
            singletonObject = singletonFactory.getObject();
            newSingleton = true;
         }
         catch (IllegalStateException ex) {
            // Has the singleton object implicitly appeared in the meantime ->
            // if yes, proceed with it since the exception indicates that state.
            singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
               throw ex;
            }
         }
         catch (BeanCreationException ex) {
            if (recordSuppressedExceptions) {
               for (Exception suppressedException : this.suppressedExceptions) {
                  ex.addRelatedCause(suppressedException);
               }
            }
            throw ex;
         }
         finally {
            if (recordSuppressedExceptions) {
               this.suppressedExceptions = null;
            }
            // 创建完成后处理
            afterSingletonCreation(beanName);
         }
         if (newSingleton) {
            // 增加到缓存中
            addSingleton(beanName, singletonObject);
         }
      }
      return (singletonObject != NULL_OBJECT ? singletonObject : null);
   }
}
```

上述代码其实使用了回调方法，使得程序可以在单例创建前后做一些准备以及处理操作，而真正的获取单例bean的方法其实并不是在此方法中实现的。这些准备操作包括如下内容：

1. 检查缓存是否已经加载过
2. 若没有加载，则记录beanName的正在加载状态
3. 加载单例前记录加载状态

```
protected void beforeSingletonCreation(String beanName) {
   // 记录这个单例bean正在加载
   if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
      throw new BeanCurrentlyInCreationException(beanName);
   }
}
```

可能觉得`beforeSingletonCreation`方法是个空实现，里面没有任何逻辑，但其实这个函数做了一个很重要的操作：记录加载状态，也就是通过`this.singletonsCurrentlyInCreation.add(beanName)`将当前正在创建的bean记录在缓存中，这样可以对循环依赖进行检测。

4. 通过调用参数传入的`ObjectFactory`的`getObject`方法实例化bean
5. 调用加载单例后的回调方法
同步骤3的记录加载状态相似，当bean加载结束后需要移除缓存中对该bean的正在加载状态的记录。

```
protected void afterSingletonCreation(String beanName) {
   if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.remove(beanName)) {
      throw new IllegalStateException("Singleton '" + beanName + "' isn't currently in creation");
   }
}
```

6. 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态

```
protected void addSingleton(String beanName, Object singletonObject) {
   synchronized (this.singletonObjects) {
      this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));
      this.singletonFactories.remove(beanName);
      this.earlySingletonObjects.remove(beanName);
      this.registeredSingletons.add(beanName);
   }
}
```
注意此处的变量在从缓存中获取单例中出现过。

7. 返回处理结果

虽然我们已经从外部了解了加载bean的逻辑架构，但现在我们还没有开始对bean加载功能的探索，之前提到过，bean的加载逻辑是在传入的`ObjectFactory`类型的参数singletionFactory中定义的，我们反推参数的获取，得到如下代码：

```
new ObjectFactory<Object>() {
   @Override
   public Object getObject() throws BeansException {
      try {
         return createBean(beanName, mbd, args);
      }
      catch (BeansException ex) {
         // Explicitly remove instance from singleton cache: It might have been put there
         // eagerly by the creation process, to allow for circular reference resolution.
         // Also remove any beans that received a temporary reference to the bean.
         destroySingleton(beanName);
         throw ex;
      }
   }
});
```

`ObjectFactory`的核心部分其实只是调用了`createBean`方法，所以我们还要在此方法中寻找真理。

## 5. 准备创建Bean

让我们看看在`createBean`函数中做了哪些工作。

```
@Override
protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {
   if (logger.isDebugEnabled()) {
      logger.debug("Creating instance of bean '" + beanName + "'");
   }
   RootBeanDefinition mbdToUse = mbd;

   // Make sure bean class is actually resolved at this point, and
   // clone the bean definition in case of a dynamically resolved Class
   // which cannot be stored in the shared merged bean definition.
   // 从配置元数据中解析此bean的class
   // 因为配置元数据中只能保存String信息，所以需要使用类加载器加载这个类，并返回一个Class<?>对象
   Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
   // 记录到缓存中，下次就不需要再从String中解析class了
   if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   }

   // Prepare method overrides.
   // 对lookup-method，replaced-method方法注入进行预处理
   try {
      mbdToUse.prepareMethodOverrides();
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, "Validation of method overrides failed", ex);
   }

   try {
      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
      // 调用后置处理器
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) {
         return bean;
      }
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            "BeanPostProcessor before instantiation of bean failed", ex);
   }

   // 创建bean实例
   Object beanInstance = doCreateBean(beanName, mbdToUse, args);
   if (logger.isDebugEnabled()) {
      logger.debug("Finished creating instance of bean '" + beanName + "'");
   }
   return beanInstance;
}
```

从代码中我们可以总结出函数完成的具体步骤及功能。

1. 根据设置的class属性或者根据className来解析class
2. 对override属性进行标记及验证
其实在Spring中没有override-method这样的配置，但是在Spring配置中是有lookup-method和replaced-method的，而这两个配置的加载其实就是将配置统一存放在`BeanDefinition`中的methodOverrides属性中，而这个函数也是针对这两个配置的
3. 应用初始化前的后置处理器，解析指定bean是否存在初始化前的短路操作
4. 创建bean

我们首先来看对override属性标记及验证的逻辑实现

### 5.1. 处理override属性

```
public void prepareMethodOverrides() throws BeanDefinitionValidationException {
   // Check that lookup methods exists.
   MethodOverrides methodOverrides = getMethodOverrides();
   if (!methodOverrides.isEmpty()) {
      Set<MethodOverride> overrides = methodOverrides.getOverrides();
      synchronized (overrides) {
         for (MethodOverride mo : overrides) {
            prepareMethodOverride(mo);
         }
      }
   }
}

protected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException {
   int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());
   if (count == 0) {
      throw new BeanDefinitionValidationException(
            "Invalid method override: no method with name '" + mo.getMethodName() +
            "' on class [" + getBeanClassName() + "]");
   }
   else if (count == 1) {
      // Mark override as not overloaded, to avoid the overhead of arg type checking.
      // 标记此方法没有被重载，避免参数类型检查的开销
      mo.setOverloaded(false);
   }
}
```

之前反复提到过，在Spring配置中存在`replaced-method`和`lookup-method`两个配置功能，而这两个配置的加载其实就是将配置统一存放在`BeanDefinition`中的`methodOverrides`属性中，这两个功能的实现原理是在bean实例化的时候如果检测到存在`methodOverrides`属性，会动态的为当前bean生成代理并使用对应的拦截器为bean做增强处理。

对于方法的匹配来说，如果一个类存在若干重载方法，那么在函数调用及增强的时候还需要根据参数类型来进行匹配，来最终确认当前调用的到底是哪个函数。但是，Spring将一部分匹配工作在这里完成了，如果当前类的方法只有一个，那么就设置该方法没有被重载，这样在后续调用的时候就可以直接使用找到的方法，而不需要进行方法的参数匹配验证了，而且还可以提前对方法的存在性进行验证，正可谓一箭双雕。

不过，你可能已经发现了在之前的XML配置文件解析过程中，已经执行了这个方法，所以一个可能的猜测是这个方法是应用在针对注解或者其他途径注册的bean上的。

### 5.2. 实例化的前置处理

在真正调用`doCreate`方法创建bean的实例前使用了这样一个方法`resolveBeforeInstantiation`对`BeanDefinition`中的属性做些前置处理。当然，无论其中是否有相应的逻辑实现我们都可以理解，因为真正逻辑实现前后留有处理函数也是可拓展的一种体现。

```
Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
if (bean != null) {
   return bean;
}


protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
   Object bean = null;
   // mbd.beforeInstantiationResolved属性默认是被初始化为null的
   if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
      // Make sure bean class is actually resolved at this point.
      // 如果这个bean factory中注册了一个InstantiationAwareBeanPostProcessor后置处理器
      // InstantiationAwareBeanPostProcessor继承自BeanPostProcessor
      if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
         Class<?> targetType = determineTargetType(beanName, mbd);
         if (targetType != null) {
            bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
            if (bean != null) {
               bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
            }
         }
      }
      mbd.beforeInstantiationResolved = (bean != null);
   }
   return bean;
}
```

在函数中提供了一个短路判断，当经过前置处理后返回的结果如果不为空，那么就会直接掠过后续bean的创建直接返回结果。这一特性很容易被忽略，但是却起着至关重要的作用，我们熟知的AOP功能就是基于这里的判断实现的。

1. 实例化前的后处理器应用

```
protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {
   for (BeanPostProcessor bp : getBeanPostProcessors()) {
      if (bp instanceof InstantiationAwareBeanPostProcessor) {
         InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
         Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
         if (result != null) {
            return result;
         }
      }
   }
   return null;
}
```

bean的实例化前调用，也就是将`AbstractBeanDefinition`转换为`BeanWrapper`前的处理。给子类一个修改`BeanDefinition`的机会，就就是说，当程序经过这个方法后，bean可能已经不是我们认为的bean了，而是或许成为了一个经过处理的代理bean，可能是通过cglib产生的，也可能是通过其他技术产生的。在AOP中会详细介绍。

2. 实例化后的后处理器应用

```
@Override
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessAfterInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}
```

在讲解从缓存中获取单例bean的时候就提到过，Spring的规则是在bean的初始化后尽可能保证将注册的或处理器`postProcessAfterInitialization`方法应用到该bean中，因为如果返回的bean不为空，那么边不会再次经历普通bean的创建过程，所以只能在这里应用后处理器的`postProcessAfterInitialization`方法。

![](https://upload-images.jianshu.io/upload_images/13068256-5cca69231ff8f132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 6. 循环依赖

### 6.1. 什么是循环依赖

循环依赖就是循环引用，就是两个或多个bean互相之间的持有对方。比如A引用B,B引用C，C引用A，最终反映为一个环。

循环依赖是无法解决的，除非有终结条件，否则就是死循环，最终导致内存溢出错误。

## 6.2. Spring如何解决循环依赖

在Spring中将循环依赖的处理分成了3种情况。查看[Dependency Resolution Process](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependency-resolution)获取更多信息。

1. 构造器循环依赖
表示通过构造器注入构成的循环依赖，此依赖是无法解决的，最后只能抛出异常表示循环依赖。
Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean标识符在创建过程中将一直保持在这个池里，因此如果在创建bean的过程中发现自己已经在“当前创建bean池”中，将抛出异常表示循环依赖，而对于创建完毕的bean将从“当前创建bean池”中清除掉。

2. setter循环依赖
表示通过setter注入方式构成的循环依赖，对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成 其他步骤(如setter注入)的bean来完成的，而且只能解决单例作用域的bean循环依赖。通过提前暴露一个工厂方法，从而使其他bean能引用到该bean，如下代码所示：

```
addSingletonFactory(beanName, new ObjectFactory<Object>() {
   @Override
   public Object getObject() throws BeansException {
      return getEarlyBeanReference(beanName, mbd, bean);
   }
});
```

3. prototype范围的循环依赖
对于prototype作用域的bean，Spring无法完成依赖注入，因为Spring容器不进行缓存”ptototype”作用域的bean，因此无法提前暴露一个创建中的bean。对于singleton作用域的bean，可以通过`setAllowCircularReferences(false)`来禁用循环引用。

## 7. 创建Bean

介绍了循环依赖后，我们继续前面的解析。在经历了`resolveBeforeInstantiation`方法后，程序有两个选择，如果创建了代理或者重写了`InstantiationAwareBeanPostProcessor`的`postProcessBeforeInstantiation`方法并在其中改变了bean，直接返回就可以了，否则要进行常规bean的创建。常规bean的创建是在`doCreateBean`中完成的。

```
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
      throws BeanCreationException {

   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   // 如果是单例，尝试从缓存中获取
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   // 如果缓存中不存在，根据指定bean使用对应的策略创建新的实例，如：工厂方法，构造函数自动注入，简单初始化
   if (instanceWrapper == null) {
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
   Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
   mbd.resolvedTargetType = beanType;

   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      // postProcessed属性默认为false
      if (!mbd.postProcessed) {
         try {
            // 应用后置处理器
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  "Post-processing of merged bean definition failed", ex);
         }
         mbd.postProcessed = true;
      }
   }

   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   // 检测是否需要提前暴露单例工厂以允许循环引用
   boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isDebugEnabled()) {
         logger.debug("Eagerly caching bean '" + beanName +
               "' to allow for resolving potential circular references");
      }
      // 在bean初始化完成前将创建实例的ObjectFactory加入工厂 
      addSingletonFactory(beanName, new ObjectFactory<Object>() {
          // 对bean再一次依赖引用，我们熟知的AOP就是在这里将advice动态织入bean中，
          // 若没有则直接返回bean，不做任何处理
         @Override
         public Object getObject() throws BeansException {
            return getEarlyBeanReference(beanName, mbd, bean);
         }
      });
   }

   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      // 注入属性
      populateBean(beanName, mbd, instanceWrapper);
      if (exposedObject != null) {
         // 调用初始化方法
         exposedObject = initializeBean(beanName, exposedObject, mbd);
      }
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
      }
   }

   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     "Bean with name '" + beanName + "' has been injected into other beans [" +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     "] in its raw version as part of a circular reference, but has eventually been " +
                     "wrapped. This means that said other beans do not use the final version of the " +
                     "bean. This is often the result of over-eager type matching - consider using " +
                     "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
            }
         }
      }
   }

   // Register bean as disposable.
   try {
      // 如果有必要，注册销毁回调方法
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
   }

   return exposedObject;
}
```

我们看看整个函数的概要思路：
1. 如果是单例首先要清除缓存
2. 实例化bean，将`BeanDefinition`转换为`BeanWrapper`
转换是一个复杂的过程，大概的功能如下：
a. 如果存在工厂方法则使用工厂方法进行初始化
b. 一个类有多个构造函数，每个构造函数有不同的参数，所有需要根据参数锁定构造函数并初始化
c. 如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认构造函数进行bean的初始化
3. `MergedBeanDefinitionPostProcessor`的应用
bean合并后的处理，`@Autowired`注解正是通过此方法实现诸如类型的预解析
4. 依赖处理
在Spring中会有循环依赖的情况，此时如果A和B都是单例，Spring的处理方式就是当创建B的时候，设计自动注入A的步骤时，并不是直接去再次创建A，而是通过放入缓存中的`ObjectFactory`来创建实例，这样就解决了循环依赖的问题
5. 属性填充
将所有的属性填充到bean的实例中
6. 循环依赖检查
在Spring中解决循环依赖只对单例有效，而对于prototype的bean，Spring没有好的解决办法，唯一要做的就是抛出异常。
7. 注册`DisposableBean`
如果配置了`destroy-method`，这里需要注册以便于在销毁的时候使用
8. 完成创建并返回

可以看到上面的步骤相当繁琐，每一步都是用大量的代码来完成。

![](https://upload-images.jianshu.io/upload_images/13068256-096f22b7009ed176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 7.1. 创建bean的实例

让我们首先从`createBeanInstance`开始。

```
protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {
   // Make sure bean class is actually resolved at this point.
   // 解析bean的class
   // 虽然前面已经进行了解析，但是还有其他方法会调用此方法，所以是针对其他方法进行的
   // 同时因为前面已经解析并记录到缓存中，所以再调用一次不会影响性能
   Class<?> beanClass = resolveBeanClass(mbd, beanName);

   // 如果无法满足反射的调用条件，抛出异常
   if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            "Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
   }
   // 工厂方法不为空则使用工厂方法初始化策略
   if (mbd.getFactoryMethodName() != null)  {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }

   // Shortcut when re-creating the same bean...
   // 缓存，当再创建此bean时加快自动注入的解析速度，用于prototype bean
   boolean resolved = false;
   boolean autowireNecessary = false;
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
   // 如果解析过，即第二次创建了，进入快速实例化过程，无需再选择调用哪一个构造方法
   if (resolved) {
      if (autowireNecessary) {
         return autowireConstructor(beanName, mbd, null, null);
      }
      else {
         return instantiateBean(beanName, mbd);
      }
   }

   // Need to determine the constructor...
   // 通过InstantiationAwareBeanPostProcessor后置处理器决定使用哪一个构造方法
   Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   // 如果后置处理器指定了构造方法或者使用了构造方法自动注入模式或者在XML文件中指定了constructor-arg元素
   // 或者getBean方法传入了额外参数，需要决定使用哪一个构造方法
   if (ctors != null ||
         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
      return autowireConstructor(beanName, mbd, ctors, args);
   }

   // No special handling: simply use no-arg constructor.
   // 如果只存在默认构造方法，则使用它
   return instantiateBean(beanName, mbd);
}
```

虽然实现比较复杂，但是在`createBeanInstance`方法中我们还是可以清晰的看到实例化的逻辑的。

1. 如果在`RootBeanDefinition`中存在`factoryMethodName`属性，或者说配置文件中配置了`factory-method`，那么在Spring中会尝试使用`instantiateUsingFactoryMethod`方法根据`RootBeanDefinition`中的配置生成bean的实例。

2. 解析构造函数并进行构造函数的初始化。因为一个bean对应的类可能会有多个构造函数，而每个构造函数的参数不同，Spring会根据参数及类型去判断最终会使用哪个构造函数进行实例化。但是，判断的过程是个比较消耗性能的操作，所以采用缓存机制，如果已经解析过了则不需要重复解析，而是直接从`RootBeanDefinition`中的属性`resolvedConstructorOrFactoryMethod`缓存的值去取，否则需要再次解析，并将解析的结果添加至`RootBeanDefinition`中的属性`resolvedConstructorOrFactoryMethod`中。

#### 7.1.1. autowireConstructor

对于实力的创建Spring中分成了两种情况，一种是通用的实例化，另一种是带有参数的实例化。带有参数的实例化过程非常复杂，因为存在着不确定性，所以在判断对应参数上做了大量工作。

```
protected BeanWrapper autowireConstructor(
      String beanName, RootBeanDefinition mbd, Constructor<?>[] ctors, Object[] explicitArgs) {

   return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}

public BeanWrapper autowireConstructor(final String beanName, final RootBeanDefinition mbd,
      Constructor<?>[] chosenCtors, final Object[] explicitArgs) {

   BeanWrapperImpl bw = new BeanWrapperImpl();
   this.beanFactory.initBeanWrapper(bw);

   Constructor<?> constructorToUse = null;
   ArgumentsHolder argsHolderToUse = null;
   Object[] argsToUse = null;

   // 如果指定了额外参数，则使用它
   if (explicitArgs != null) {
      argsToUse = explicitArgs;
   }
   else {
      // 否则，尝试从缓存中获取
      // 第一次创建时，可以视为跳过此步，因为缓存为空
      Object[] argsToResolve = null;
      synchronized (mbd.constructorArgumentLock) {
         constructorToUse = (Constructor<?>) mbd.resolvedConstructorOrFactoryMethod;
         if (constructorToUse != null && mbd.constructorArgumentsResolved) {
            // Found a cached constructor...
            argsToUse = mbd.resolvedConstructorArguments;
            if (argsToUse == null) {
               argsToResolve = mbd.preparedConstructorArguments;
            }
         }
      }
      if (argsToResolve != null) {
         argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
      }
   }
  
   // 没有缓存时
   if (constructorToUse == null) {
      // Need to resolve the constructor.
      boolean autowiring = (chosenCtors != null ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
      ConstructorArgumentValues resolvedValues = null;

      int minNrOfArgs;
      // 如果指定了参数，则根据参数选择构造方法
      if (explicitArgs != null) {
         minNrOfArgs = explicitArgs.length;
      }
      else {
         // 否则，根据XML配置文件中的信息选择
         ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
         resolvedValues = new ConstructorArgumentValues();
         minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
      }

      // Take specified constructors, if any.
      Constructor<?>[] candidates = chosenCtors;
      // 通过反射获取构造方法
      if (candidates == null) {
         Class<?> beanClass = mbd.getBeanClass();
         try {
            candidates = (mbd.isNonPublicAccessAllowed() ?
                  beanClass.getDeclaredConstructors() : beanClass.getConstructors());
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  "Resolution of declared constructors on bean Class [" + beanClass.getName() +
                  "] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex);
         }
      }
      // 对构造方法进行排序，public方法优先，按参数数量降序。
      // 即首先按public排序，此时前半部分为public构造函数，后半部分为其他构造函数，
      // 再对这两部分分别按参数数量排序，参数数量多的排在前面
      AutowireUtils.sortConstructors(candidates);
      int minTypeDiffWeight = Integer.MAX_VALUE;
      Set<Constructor<?>> ambiguousConstructors = null;
      LinkedList<UnsatisfiedDependencyException> causes = null;
      // 从构造方法中选择出最适配的一个
      for (Constructor<?> candidate : candidates) {
         // 获取构造方法的参数
         Class<?>[] paramTypes = candidate.getParameterTypes();

         // 如果找到适配的构造方法，则退出
         // 可能对 argsToUse.length > paramTypes.length感到疑惑，在循环中第一次执行时，
         // constructorToUse != null肯定返回false，所以第二个判断就被短路了，
         // 即使未指定额外参数，也没有缓存导致argsToUse为null 
         // 但是却不会执行到这步，因此不会出现NPE，而在下面的部分， 
         // constructorToUse与argsToUse是同时赋值的，所以还会不会出现NPE
         if (constructorToUse != null && argsToUse.length > paramTypes.length) {
            // Already found greedy constructor that can be satisfied ->
            // do not look any further, there are only less greedy constructors left.
            break;
         }
         // 如果参数数量少于最小参数数量，则跳过此构造方法
         // 因为需要尽量找到参数符合并且参数数量最多的构造方法，此时参数数量已经不符合
         if (paramTypes.length < minNrOfArgs) {
            continue;
         }

         ArgumentsHolder argsHolder;
         // XML中指定了构造方法参数
         if (resolvedValues != null) {
            try {
               // 根据注解获取构造方法参数的名称，如果编译时禁用debug信息，那么需要使用
               // @ConstructorProperties注解主动提供参数名称
               String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
               // 如果没有使用此注解，那么Spring会自动通过debug信息寻找参数名称
               if (paramNames == null) {
                  ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                  if (pnd != null) {
                     paramNames = pnd.getParameterNames(candidate);
                  }
               }
               // 封装参数名称与类型
               argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                     getUserDeclaredConstructor(candidate), autowiring);
            }
            catch (UnsatisfiedDependencyException ex) {
               if (this.beanFactory.logger.isTraceEnabled()) {
                  this.beanFactory.logger.trace(
                        "Ignoring constructor [" + candidate + "] of bean '" + beanName + "': " + ex);
               }
               // Swallow and try next constructor.
               if (causes == null) {
                  causes = new LinkedList<UnsatisfiedDependencyException>();
               }
               causes.add(ex);
               continue;
            }
         }
         // 否则，使用getBean方法提供的额外参数
         else {
            // Explicit arguments given -> arguments length must match exactly.
            // 严格匹配，构造方法参数数量需要与额外参数数量相同
            if (paramTypes.length != explicitArgs.length) {
               continue;
            }
            argsHolder = new ArgumentsHolder(explicitArgs);
         }

         // 检查是否有不确定的构造方法存在，例如不同构造方法的参数为父子关系
         int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
               argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
         // Choose this constructor if it represents the closest match.
         // 因为可能存在多个满足基本条件（参数数量满足）的构造方法，所以需要选择最匹配的构造方法
         if (typeDiffWeight < minTypeDiffWeight) {
            constructorToUse = candidate;
            argsHolderToUse = argsHolder;
            argsToUse = argsHolder.arguments;
            minTypeDiffWeight = typeDiffWeight;
            ambiguousConstructors = null;
         }
         // 如果出现权重等同的构造方法，那么记录冲突的构造方法
         else if (constructorToUse != null && typeDiffWeight == minTypeDiffWeight) {
            if (ambiguousConstructors == null) {
               ambiguousConstructors = new LinkedHashSet<Constructor<?>>();
               ambiguousConstructors.add(constructorToUse);
            }
            ambiguousConstructors.add(candidate);
         }
      }
      
      // 如果在所有构造方法中都未找到匹配的，则抛出异常
      if (constructorToUse == null) {
         if (causes != null) {
            UnsatisfiedDependencyException ex = causes.removeLast();
            for (Exception cause : causes) {
               this.beanFactory.onSuppressedException(cause);
            }
            throw ex;
         }
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               "Could not resolve matching constructor " +
               "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");
      }
      // 或者存在多个符合的构造方法，抛出异常
      else if (ambiguousConstructors != null && !mbd.isLenientConstructorResolution()) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               "Ambiguous constructor matches found in bean '" + beanName + "' " +
               "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): " +
               ambiguousConstructors);
      }

      if (explicitArgs == null) {
         // 记录到缓存中，当然前提是不能是通过指定额外参数的getBean调用的，
         // 因为下次调用参数可能会发生变化，记录到缓存无用，只会引发错误
         argsHolderToUse.storeCache(mbd, constructorToUse);
      }
   }

   try {
      Object beanInstance;

      if (System.getSecurityManager() != null) {
         final Constructor<?> ctorToUse = constructorToUse;
         final Object[] argumentsToUse = argsToUse;
         beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {
            @Override
            public Object run() {
               // 使用构造方法实例化这个bean
               return beanFactory.getInstantiationStrategy().instantiate(
                     mbd, beanName, beanFactory, ctorToUse, argumentsToUse);
            }
         }, beanFactory.getAccessControlContext());
      }
      else {
         beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(
               mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
      }

      bw.setBeanInstance(beanInstance);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            "Bean instantiation via constructor failed", ex);
   }
}
```

逻辑很复杂，代码量也很大。我们总览一下整个方法，其实现的功能考虑了以下几个方面：

1. 函数参数的确定
a. 根据explicitArgs参数判断
如果传入的参数explicitArgs不为空，那么可以直接确定参数，因为explicitArgs参数是在调用`getBean`的时候用户指定的，在`BeanFactory`中存在这样的方法：`Object getBean(String name, Object... args) throws BeansException;`
b. 缓存中获取
除此之外，如果确定参数的方法之前已经分析过，也就是说构造函数参数已经记录在缓存中，那么便可以直接拿来用
c. 配置文件中获取
经过之前的分析，我们知道Spring配置文件中的信息经过转换都会通过`BeanDefinition`实例承载，也就是参数mbd中包含，那么就可以通过调用`mbd.getConstructorArgumentValues()`来获取配置的构造函数信息。
```
private int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,
      ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {
   // 获取类型转换器
   TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();
   TypeConverter converter = (customConverter != null ? customConverter : bw);
   BeanDefinitionValueResolver valueResolver =
         new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);
   // 获取配置文件中指定的constructor-arg元素数量
   int minNrOfArgs = cargs.getArgumentCount();
  
   // 对于指定index属性的constructor-arg
   for (Map.Entry<Integer, ConstructorArgumentValues.ValueHolder> entry : cargs.getIndexedArgumentValues().entrySet()) {
      // 获取index属性的值
      int index = entry.getKey();
      // 如果指定的index < 0 ，抛出异常
      if (index < 0) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName,
               "Invalid constructor argument index: " + index);
      }
      // 如果constructor-arg元素的数量为2，但是index为3，那么要求构造方法实际上至少要有4个参数，
      // 注意，index是从0开始计数的，所以需要更新参数数量
      if (index > minNrOfArgs) {
         minNrOfArgs = index + 1;
      }
      ConstructorArgumentValues.ValueHolder valueHolder = entry.getValue();
      // 如果参数类型已经转换，直接记录
      if (valueHolder.isConverted()) {
         resolvedValues.addIndexedArgumentValue(index, valueHolder);
      }
      // 否则，需要对参数类型进行转换。注意，在XML配置文件中的参数都是字符串，
      // 如果参数要求是Integer或者是一个对其他bean的引用等，需要进行类型转换
      else {
         Object resolvedValue =
               valueResolver.resolveValueIfNecessary("constructor argument", valueHolder.getValue());
         ConstructorArgumentValues.ValueHolder resolvedValueHolder =
               new ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());
         resolvedValueHolder.setSource(valueHolder);
         // 记录
         resolvedValues.addIndexedArgumentValue(index, resolvedValueHolder);
      }
   }

   // 对于未指定index的constructor-arg，过程相似
   for (ConstructorArgumentValues.ValueHolder valueHolder : cargs.getGenericArgumentValues()) {
      if (valueHolder.isConverted()) {
         resolvedValues.addGenericArgumentValue(valueHolder);
      }
      else {
         Object resolvedValue =
               valueResolver.resolveValueIfNecessary("constructor argument", valueHolder.getValue());
         ConstructorArgumentValues.ValueHolder resolvedValueHolder =
               new ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());
         resolvedValueHolder.setSource(valueHolder);
         resolvedValues.addGenericArgumentValue(resolvedValueHolder);
      }
   }
   // 返回最少需要的构造方法参数数量
   return minNrOfArgs;
}
```
2. 构造函数的确定
经过第一步后已经确定了构造函数参数，接下来的任务就是根据构造函数参数在构造函数中锁定对应的构造参数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数进行排序，这样可以在遍历的情况下快速判断后面的构造函数参数个数是否符合条件。
```
public static void sortConstructors(Constructor<?>[] constructors) {
   Arrays.sort(constructors, new Comparator<Constructor<?>>() {
      @Override
      public int compare(Constructor<?> c1, Constructor<?> c2) {
         boolean p1 = Modifier.isPublic(c1.getModifiers());
         boolean p2 = Modifier.isPublic(c2.getModifiers());
         if (p1 != p2) {
            return (p1 ? -1 : 1);
         }
         int c1pl = c1.getParameterTypes().length;
         int c2pl = c2.getParameterTypes().length;
         return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0));
      }
   });
}
```
由于在配置文件中并不唯一限制使用参数位置索引的方式去创建，同样还支持使用指定参数名称设置参数值的情况，那么这种情况就需要首先确定构造函数中的参数名称。
获取参数名称的方式有两种。一种是通过注解的方式直接获取，另一种就是使用Spring提供的工具类`ParamterNameDiscoverer`来获取。
3. 根据确定的构造函数转换对应的参数类型
主要使用Spring中提供的类型转换器和用户提供的自定义类型转换器来进行转换
4. 构造函数不确定性的验证
当然，有时候即使构造函数，参数名称，参数类型，参数值都确定了也不一定可以直接锁定构造函数，不同构造函数的参数为父子关系，所以Spring在最后又做了一次验证。
5. 如果没有指定额外参数，则记录到缓存中
```
public void storeCache(RootBeanDefinition mbd, Object constructorOrFactoryMethod) {
   synchronized (mbd.constructorArgumentLock) {
      mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;
      mbd.constructorArgumentsResolved = true;
      if (this.resolveNecessary) {
         mbd.preparedConstructorArguments = this.preparedArguments;
      }
      else {
         mbd.resolvedConstructorArguments = this.arguments;
      }
   }
}
```
6. 根据实例化策略以及得到的构造函数及构造函数参数实例化bean，此步后面一起讲解。

#### 7.1.2. instantiateBean

经历了带有参数的实例构造，会非常轻松的理解不带参数的构造函数实例化过程。

```
protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
   try {
      Object beanInstance;
      final BeanFactory parent = this;
      if (System.getSecurityManager() != null) {
         beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {
            @Override
            public Object run() {
               return getInstantiationStrategy().instantiate(mbd, beanName, parent);
            }
         }, getAccessControlContext());
      }
      else {
         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
      }
      BeanWrapper bw = new BeanWrapperImpl(beanInstance);
      initBeanWrapper(bw);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
   }
}
```

此方法并没有什么实质性的逻辑，在带有参数的实例构造中，Spring把精力放在构造函数以及参数的匹配上，所以没有参数的话那将是非常简单的一件事，直接调用实例化策略进行实例化就行了。

#### 7.1.3 实例化策略

实例化过程中反复提到过实例化策略，这是做什么用呢？经过前面的分析，我们已经得到了足以实例化的所有相关信息，完成可以使用最简单的反射方法直接反射来构造实例对象，但是Spring并没有这么做。

```
@Override
public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {
   // Don't override the class with CGLIB if no overrides.
   // 如果没有使用lookup-mehod或replaced-method方法注入，那么不进行CGLIB代理
   if (bd.getMethodOverrides().isEmpty()) {
      Constructor<?> constructorToUse;
      synchronized (bd.constructorArgumentLock) {
         // 获取前面解析得到的构造方法
         constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;
         // 如果使用的是无参构造方法，那么通过反射获取它
         if (constructorToUse == null) {
            final Class<?> clazz = bd.getBeanClass();
            if (clazz.isInterface()) {
               throw new BeanInstantiationException(clazz, "Specified class is an interface");
            }
            try {
               if (System.getSecurityManager() != null) {
                  constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<Constructor<?>>() {
                     @Override
                     public Constructor<?> run() throws Exception {
                        return clazz.getDeclaredConstructor((Class[]) null);
                     }
                  });
               }
               else {
                  constructorToUse = clazz.getDeclaredConstructor((Class[]) null);
               }
               bd.resolvedConstructorOrFactoryMethod = constructorToUse;
            }
            catch (Throwable ex) {
               throw new BeanInstantiationException(clazz, "No default constructor found", ex);
            }
         }
      }
      // 通过反射实例化
      return BeanUtils.instantiateClass(constructorToUse);
   }
   else {
      // Must generate CGLIB subclass.
      return instantiateWithMethodInjection(bd, beanName, owner);
   }
}
```
```
// 默认实现，此方法被子类重写
protected Object instantiateWithMethodInjection(RootBeanDefinition bd, String beanName, BeanFactory owner) {
   throw new UnsupportedOperationException("Method Injection not supported in SimpleInstantiationStrategy");
}

@Override
protected Object instantiateWithMethodInjection(RootBeanDefinition bd, String beanName, BeanFactory owner) {
   return instantiateWithMethodInjection(bd, beanName, owner, null);
}

@Override
protected Object instantiateWithMethodInjection(RootBeanDefinition bd, String beanName, BeanFactory owner,
      Constructor<?> ctor, Object... args) {

   // Must generate CGLIB subclass...
   return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);
}

public Object instantiate(Constructor<?> ctor, Object... args) {
   // 通过CGLIB代理实例化子类
   Class<?> subclass = createEnhancedSubclass(this.beanDefinition);
   Object instance;
   if (ctor == null) {
      instance = BeanUtils.instantiateClass(subclass);
   }
   else {
      try {
         Constructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
         instance = enhancedSubclassConstructor.newInstance(args);
      }
      catch (Exception ex) {
         throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
               "Failed to invoke constructor for CGLIB enhanced subclass [" + subclass.getName() + "]", ex);
      }
   }
   // SPR-10785: set callbacks directly on the instance instead of in the
   // enhanced class (via the Enhancer) in order to avoid memory leaks.
   Factory factory = (Factory) instance;
   // 对lookup-method及replaced-method进行增强代理
   factory.setCallbacks(new Callback[] {NoOp.INSTANCE,
         new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
         new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
   return instance;
}
```

程序中，首先判断如果`beanDefinition.getMethodOverrides()`为空也就是用户没有使用replaced-method或者lookup-method配置，那么直接使用反射的方式，简单快捷，但是如果使用了这两个特性，再直接使用反射的方法创建实例就不妥了。因为需要将这个配置提供的功能切入进去，所以就必须使用动态代理的方式将包含两个特性所对应的逻辑的拦截增强器设置进去，这样才能保证在调用方法的时候会被相应的拦截器增强，返回值为包含拦截器的代理实例。

而直接反射的过程则很简单，直接使用构造方法即可。
```
public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {
   Assert.notNull(ctor, "Constructor must not be null");
   try {
      ReflectionUtils.makeAccessible(ctor);
      return ctor.newInstance(args);
   }
   catch (InstantiationException ex) {
      throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex);
   }
   catch (IllegalAccessException ex) {
      throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex);
   }
   catch (IllegalArgumentException ex) {
      throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex);
   }
   catch (InvocationTargetException ex) {
      throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException());
   }
}
```

### 7.2. 记录创建bean的ObjectFactory

在`doCreateBean`中有这么一段代码：

```
boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
      isSingletonCurrentlyInCreation(beanName));
if (earlySingletonExposure) {
   if (logger.isDebugEnabled()) {
      logger.debug("Eagerly caching bean '" + beanName +
            "' to allow for resolving potential circular references");
   }
   addSingletonFactory(beanName, new ObjectFactory<Object>() {
      @Override
      public Object getObject() throws BeansException {
         return getEarlyBeanReference(beanName, mbd, bean);
      }
   });
}
```

这段代码并不复杂，但很难弄懂其中的含义。我们需要从全局的角度思考Spring的依赖解决办法。

1.earlySingletonExposure: 从字面意思理解就是提早曝光的单例，我们暂时不定义它的学名，只看有哪些条件影响这个值。
2. mbd.isSingleton(): 此RootBeanDefinition代表的是否是单例
3. this.allowCircularReferences: 是否允许循环依赖，在配置文件中文法对此属性进行配置，但是提供了设置函数setAllowCircularReferences。在前面循环依赖的内容中提到过。
4. isSingletonCurrentlyInCreation(beanName): 该bean是否正在创建中。在Spring中，有专门的属性singletonCurrentlyInCreation来记录bean的加载状态，在bean开始创建前会将beanName记录在属性中，在bean创建结束后会将beanName从属性中移除。关于此属性我们在getSingleton中提及过。

当这三个条件都满足时会执行`addSingletonFactory`操作，那么增加`SingletonFactory`的作用是什么，又在哪里被调用呢？

我们还是以最简单的AB循环为例，类A中含有属性B，类B中还有属性A，那么初始化beanA的过程如下所示：

![](https://upload-images.jianshu.io/upload_images/13068256-69ae6fcfd814a462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在创建B时，填充属性调用`getBean`方法，关键在这里。之前我们提到过，在这个函数中我们并不是直接去实例化bean，而是先去检测缓存中是否有已经创建好的对应的bean或者已经创建好的`ObjectFactory`，而此时对于A的`ObjectFactory`我们早已经创建，所以便不会向后执行，而是直接调用`ObjectFactory`创建A。

```
addSingletonFactory(beanName, new ObjectFactory<Object>() {
   @Override
   public Object getObject() throws BeansException {
      return getEarlyBeanReference(beanName, mbd, bean);
   }
});

protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
   Object exposedObject = bean;
   if (bean != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
            SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
            exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
            if (exposedObject == null) {
               return null;
            }
         }
      }
   }
   return exposedObject;
}
```

`getEarlyBeanReference`方法中并没有太多逻辑，只是对后处理器的处理。至此我们理清了Spring对循环依赖的解决方案。

### 7.3. 属性注入

在了解循环依赖的时候，我们反复提到了`populationBean`这个方法，也了解了这个函数的主要功能就是属性填充，那么是如何实现的呢？

```
protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
   // 获取配置元数据中<property />元素的内容
   PropertyValues pvs = mbd.getPropertyValues();

   if (bw == null) {
      if (!pvs.isEmpty()) {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
      }
      else {
         // Skip property population phase for null instance.
         return;
      }
   }

   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   boolean continueWithPropertyPopulation = true;

   // 应用InstantiationAwareBeanPostProcessor后置处理器
   if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
      for (BeanPostProcessor bp : getBeanPostProcessors()) {
         if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
               continueWithPropertyPopulation = false;
               break;
            }
         }
      }
   }

   if (!continueWithPropertyPopulation) {
      return;
   }

   // 自动注入
   if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

      // Add property values based on autowire by name if applicable.
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
         autowireByName(beanName, mbd, bw, newPvs);
      }

      // Add property values based on autowire by type if applicable.
      if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
         autowireByType(beanName, mbd, bw, newPvs);
      }

      pvs = newPvs;
   }

   // 检查是否存在InstantiationAwareBeanPostProcessor后置处理器
   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   // 检查是否需要进行类型检查
   boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

   // 进行依赖检查以及后置处理
   if (hasInstAwareBpps || needsDepCheck) {
      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      if (hasInstAwareBpps) {
         for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
               if (pvs == null) {
                  return;
               }
            }
         }
      }
      // 依赖检查，对应dependencyCheck属性，spring3.0后已弃用此属性
      if (needsDepCheck) {
         checkDependencies(beanName, mbd, filteredPds, pvs);
      }
   }

   // 设置<property />中指定的属性
   applyPropertyValues(beanName, mbd, bw, pvs);
}
```

在`populationBean`中提供了这样的处理流程

1. `InstantiationAwareBeanPostProcessor`处理器的`postProcessAfterInstantiation`函数的应用，此函数可以控制程序是否继续进行属性填充
2. 根据自动注入类型(byName/byType)，提取依赖的bean，并统一存入`PropertyValues`。
3. 应用`InstantiationAwareBeanPostProcessor`处理器的`postProcessPropertyValues`方法，对属性获取完毕填充前对属性的再次处理，典型应用是`RequiredAnnotationBeanPostProcessor`类中对属性的验证。
`InstantiationAwareBeanPostProcessor`简单介绍:[https://blog.csdn.net/u010634066/article/details/80321854](https://blog.csdn.net/u010634066/article/details/80321854)
4. 将所有的PropertyValues中的属性填充到BeanWrapper中。

#### 7.3.1. autowireByName

```
protected void autowireByName(
      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

   // 寻找可以满足属性注入的bean
   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
   for (String propertyName : propertyNames) {
      if (containsBean(propertyName)) {
         // 获取这个bean
         Object bean = getBean(propertyName);
         // 记录信息
         pvs.add(propertyName, bean);
         // 注册依赖关系
         registerDependentBean(propertyName, beanName);
         if (logger.isDebugEnabled()) {
            logger.debug("Added autowiring by name from bean name '" + beanName +
                  "' via property '" + propertyName + "' to bean named '" + propertyName + "'");
         }
      }
      else {
         if (logger.isTraceEnabled()) {
            logger.trace("Not autowiring property '" + propertyName + "' of bean '" + beanName +
                  "' by name: no matching bean found");
         }
      }
   }
}
```

如果了解了autowire的使用方法，理解这个函数的功能并不困难，无非是在传入的参数bw中找出已经加载的bean，并递归实例化，进入加入到pvs中。

#### 7.3.2. autowireByType

autowireByType与autowireByName对于我们理解与使用来说复杂程度都很相似，但是其实现功能的复杂度却完成不一样。

```
protected void autowireByType(
      String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

   // 获取类型转换器
   TypeConverter converter = getCustomTypeConverter();
   if (converter == null) {
      converter = bw;
   }

   Set<String> autowiredBeanNames = new LinkedHashSet<String>(4);
   // 寻找满足注入条件的bean
   String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
   for (String propertyName : propertyNames) {
      try {
         // 获取这个bean的属性描述符
         PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
         // Don't try autowiring by type for type Object: never makes sense,
         // even if it technically is a unsatisfied, non-simple property.
         // 不会自动注入Object类型的属性
         if (Object.class != pd.getPropertyType()) {
            // 寻找这个属性的setter方法
            MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
            // Do not allow eager init for type matching in case of a prioritized post-processor.
            boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());
            DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
             // 解析指定beanName的属性所匹配的值，并把解析到的属性名称存储到autowireBeanNames中，
             // 当属性存在多个封装bean时如：@Autowired private List<A> aList;将会找到所有匹配类型A的bean并将其注入
            Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
            if (autowiredArgument != null) {
               pvs.add(propertyName, autowiredArgument);
            }
            for (String autowiredBeanName : autowiredBeanNames) {
               // 注册依赖关系
               registerDependentBean(autowiredBeanName, beanName);
               if (logger.isDebugEnabled()) {
                  logger.debug("Autowiring by type from bean name '" + beanName + "' via property '" +
                        propertyName + "' to bean named '" + autowiredBeanName + "'");
               }
            }
            autowiredBeanNames.clear();
         }
      }
      catch (BeansException ex) {
         throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
      }
   }
}
```

实现根据名称自动匹配的第一步就是寻找bw中需要依赖注入的属性，对于根据类型自动匹配的实现第一步也是如此，然后遍历这些属性并寻找类型匹配的bean，其中最复杂的就是寻找类型匹配的bean。寻找类型匹配的逻辑实现封装在了`resolveDependency`函数中。

```
@Override
public Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName,
      Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {

   descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
   // javaUtilOptionalClass类的特殊处理
   if (javaUtilOptionalClass == descriptor.getDependencyType()) {
      return new OptionalDependencyFactory().createOptionalDependency(descriptor, requestingBeanName);
   }
   // ObjectFactory或ObjectProvider类的特殊处理
   else if (ObjectFactory.class == descriptor.getDependencyType() ||
         ObjectProvider.class == descriptor.getDependencyType()) {
      return new DependencyObjectProvider(descriptor, requestingBeanName);
   }
   // javaxInjectProviderClass类的特殊处理
   else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
      return new Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);
   }
   else {
      // 如果有必要则建立代理对依赖目标进行延迟处理
      Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
            descriptor, requestingBeanName);
      if (result == null) {
         result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
      }
      return result;
   }
}
```
```
public Object doResolveDependency(DependencyDescriptor descriptor, String beanName,
      Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {
   // 获取注入点
   InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
   try {
      Object shortcut = descriptor.resolveShortcut(this);
      if (shortcut != null) {
         return shortcut;
      }

      // 获取属性类型
      Class<?> type = descriptor.getDependencyType();
      // 解析@Value注解
      Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
      if (value != null) {
         if (value instanceof String) {
            String strVal = resolveEmbeddedValue((String) value);
            BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
            value = evaluateBeanDefinitionString(strVal, bd);
         }
         TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
         return (descriptor.getField() != null ?
               converter.convertIfNecessary(value, type, descriptor.getField()) :
               converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
      }

      // 解析集合类型
      Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
      if (multipleBeans != null) {
         return multipleBeans;
      }

      // 寻找类型匹配的bean
      Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
      // 如果没有合适的候选bean，同时这个属性是必需的，那么抛出异常
      if (matchingBeans.isEmpty()) {
         if (isRequired(descriptor)) {
            raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
         }
         return null;
      }

      String autowiredBeanName;
      Object instanceCandidate;

      // 如果有多个候选bean
      if (matchingBeans.size() > 1) {
         // 寻找最合适的，比如指定了@Primary，如果没有指定primary，则选取优先级最高的bean，
         // 选取不到的话再根据beanName是否与此属性名称相同决定
         autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
         if (autowiredBeanName == null) {
            if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
               return descriptor.resolveNotUnique(type, matchingBeans);
            }
            else {
               // In case of an optional Collection/Map, silently ignore a non-unique case:
               // possibly it was meant to be an empty collection of multiple regular beans
               // (before 4.3 in particular when we didn't even look for collection beans).
               return null;
            }
         }
         instanceCandidate = matchingBeans.get(autowiredBeanName);
      }
      // 如果只有一个符合的bean，直接获取其结果
      else {
         // We have exactly one match.
         Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
         autowiredBeanName = entry.getKey();
         instanceCandidate = entry.getValue();
      }

      if (autowiredBeanNames != null) {
         autowiredBeanNames.add(autowiredBeanName);
      }
      return (instanceCandidate instanceof Class ?
            descriptor.resolveCandidate(autowiredBeanName, type, this) : instanceCandidate);
   }
   finally {
      ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
   }
}
```
```
private Object resolveMultipleBeans(DependencyDescriptor descriptor, String beanName,
      Set<String> autowiredBeanNames, TypeConverter typeConverter) {

   Class<?> type = descriptor.getDependencyType();
   // 如果是数组类型
   if (type.isArray()) {
      // 获取其元件类型，假如数组为String[]，元件类型则为String
      Class<?> componentType = type.getComponentType();
      ResolvableType resolvableType = descriptor.getResolvableType();
      // 获取参数类型
      Class<?> resolvedArrayType = resolvableType.resolve();
      // 如果参数与依赖的属性不一致，那么参数类型优先
      if (resolvedArrayType != null && resolvedArrayType != type) {
         type = resolvedArrayType;
         componentType = resolvableType.getComponentType().resolve();
      }
      if (componentType == null) {
         return null;
      }
      // 寻找类型符合的bean
      Map<String, Object> matchingBeans = findAutowireCandidates(beanName, componentType,
            new MultiElementDescriptor(descriptor));
      if (matchingBeans.isEmpty()) {
         return null;
      }
      // 记录符合的bean名称
      if (autowiredBeanNames != null) {
         autowiredBeanNames.addAll(matchingBeans.keySet());
      }
      TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
      // 如果需要，进行类型转换
      Object result = converter.convertIfNecessary(matchingBeans.values(), type);
      if (getDependencyComparator() != null && result instanceof Object[]) {
         Arrays.sort((Object[]) result, adaptDependencyComparator(matchingBeans));
      }
      return result;
   }
   // 如果是集合类型，处理过程与数组类型一直
   else if (Collection.class.isAssignableFrom(type) && type.isInterface()) {
      Class<?> elementType = descriptor.getResolvableType().asCollection().resolveGeneric();
      if (elementType == null) {
         return null;
      }
      Map<String, Object> matchingBeans = findAutowireCandidates(beanName, elementType,
            new MultiElementDescriptor(descriptor));
      if (matchingBeans.isEmpty()) {
         return null;
      }
      if (autowiredBeanNames != null) {
         autowiredBeanNames.addAll(matchingBeans.keySet());
      }
      TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
      Object result = converter.convertIfNecessary(matchingBeans.values(), type);
      if (getDependencyComparator() != null && result instanceof List) {
         Collections.sort((List<?>) result, adaptDependencyComparator(matchingBeans));
      }
      return result;
   }
   // 如果是Map，此时注意key一定要是String类型
   else if (Map.class == type) {
      ResolvableType mapType = descriptor.getResolvableType().asMap();
      Class<?> keyType = mapType.resolveGeneric(0);
      if (String.class != keyType) {
         return null;
      }
      Class<?> valueType = mapType.resolveGeneric(1);
      if (valueType == null) {
         return null;
      }
      Map<String, Object> matchingBeans = findAutowireCandidates(beanName, valueType,
            new MultiElementDescriptor(descriptor));
      if (matchingBeans.isEmpty()) {
         return null;
      }
      if (autowiredBeanNames != null) {
         autowiredBeanNames.addAll(matchingBeans.keySet());
      }
      return matchingBeans;
   }
   else {
      return null;
   }
}
```

寻找类型的匹配执行顺序时，首先尝试使用解析器进行解析，如果解析器没有成功解析，那么可能是使用默认的解析器没有做任何处理，或者是使用了自定义的解析器，但是对于集合等类型不在解析范围内，所以再次对不同类型进行不同情况的处理，虽说对于不同类型的处理方式不一致，但大致的思路还是相似的，所以只对数组类型进行了注释。

#### 7.3.3. applyPropertyValues

程序运行到这里，已经完成了对所有注入属性的获取，但是获取的属性是以`PropertyValues`形式存在的，还并没有应用到已经实例化的bean中，这一工作在`applyPropertyValues`中。

```
protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
   if (pvs == null || pvs.isEmpty()) {
      return;
   }

   MutablePropertyValues mpvs = null;
   List<PropertyValue> original;

   if (System.getSecurityManager() != null) {
      if (bw instanceof BeanWrapperImpl) {
         ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
      }
   }

   if (pvs instanceof MutablePropertyValues) {
      mpvs = (MutablePropertyValues) pvs;
      // 如果在之前已经进行了类型转换，那么可以直接设置到beanWrapper中
      if (mpvs.isConverted()) {
         // Shortcut: use the pre-converted values as-is.
         try {
            bw.setPropertyValues(mpvs);
            return;
         }
         catch (BeansException ex) {
            throw new BeanCreationException(
                  mbd.getResourceDescription(), beanName, "Error setting property values", ex);
         }
      }
      original = mpvs.getPropertyValueList();
   }
   else {
      original = Arrays.asList(pvs.getPropertyValues());
   }

   TypeConverter converter = getCustomTypeConverter();
   if (converter == null) {
      converter = bw;
   }
   // 获取对应的解析器
   BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

   // Create a deep copy, resolving any references for values.
   // 创建深拷贝，原因在于prototype bean
   List<PropertyValue> deepCopy = new ArrayList<PropertyValue>(original.size());
   boolean resolveNecessary = false;
   for (PropertyValue pv : original) {
      if (pv.isConverted()) {
         deepCopy.add(pv);
      }
      else {
         String propertyName = pv.getName();
         Object originalValue = pv.getValue();
         Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
         Object convertedValue = resolvedValue;
         boolean convertible = bw.isWritableProperty(propertyName) &&
               !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
         if (convertible) {
            convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
         }
         // Possibly store converted value in merged bean definition,
         // in order to avoid re-conversion for every created bean instance.
         if (resolvedValue == originalValue) {
            if (convertible) {
               pv.setConvertedValue(convertedValue);
            }
            deepCopy.add(pv);
         }
         else if (convertible && originalValue instanceof TypedStringValue &&
               !((TypedStringValue) originalValue).isDynamic() &&
               !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
            pv.setConvertedValue(convertedValue);
            deepCopy.add(pv);
         }
         else {
            resolveNecessary = true;
            deepCopy.add(new PropertyValue(pv, convertedValue));
         }
      }
   }
   if (mpvs != null && !resolveNecessary) {
      mpvs.setConverted();
   }

   // Set our (possibly massaged) deep copy.
   try {
      bw.setPropertyValues(new MutablePropertyValues(deepCopy));
   }
   catch (BeansException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, "Error setting property values", ex);
   }
}
```

### 7.4. 初始化bean

大家应该记得在bean配置时bean中有一个`init-method`的属性，这个属性的作用是在bean实例化前调用`init-method`指定的方法来根据用户业务进行相应的实例化。我们现在就已经进入这个方法了，首先看一下这个方法的执行位置，Spring已经执行过bean的实例化，并进行了属性的填充，就在这是将会调用用户设定的初始化方法。

```
protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
   if (System.getSecurityManager() != null) {
      AccessController.doPrivileged(new PrivilegedAction<Object>() {
         @Override
         public Object run() {
            // 对特殊的bean处理:Aware,BeanClassLoadAware,BeanFactoryAware
            invokeAwareMethods(beanName, bean);
            return null;
         }
      }, getAccessControlContext());
   }
   else {
      invokeAwareMethods(beanName, bean);
   }

   Object wrappedBean = bean;
   // 应用后置处理器
   if (mbd == null || !mbd.isSynthetic()) {
      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   }

   try {
      // 调用init-method方法
      invokeInitMethods(beanName, wrappedBean, mbd);
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            (mbd != null ? mbd.getResourceDescription() : null),
            beanName, "Invocation of init method failed", ex);
   }

   // 应用后置处理器
   if (mbd == null || !mbd.isSynthetic()) {
      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
   }
   return wrappedBean;
}
```

#### 7.4.1. 激活Aware方法

关于`Aware`的使用，查看[1.6.2. ApplicationContextAware and BeanNameAware](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-aware)和[1.6.3. Other Aware Interfaces](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aware-list)获取更多信息。

```
private void invokeAwareMethods(final String beanName, final Object bean) {
   if (bean instanceof Aware) {
      if (bean instanceof BeanNameAware) {
         ((BeanNameAware) bean).setBeanName(beanName);
      }
      if (bean instanceof BeanClassLoaderAware) {
         ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());
      }
      if (bean instanceof BeanFactoryAware) {
         ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
      }
   }
}
```

看一下此方法的实现方式，可以说是很简单。由于此时我们只在对BeanFactory进行分析，而不是ApplicationContext，所以此处只有这几个Aware。

#### 7.4.2. 处理器的应用

`BeanPostProcessor`相信大家都不会陌生，这是Spring开放架构中一个必不可少的亮点，给用户充足的权限去更改或拓展Spring。`BeanPostProcessor`的使用位置就是这里，在调用客户自定义初始化方法之前以及调用之后分别会调用`BeanPostProcessor`的`postProcessBeforeInitialization`和`postProcessAfterInitialization`方法，使用户可以根据自己的业务需求进行相应的处理。关于`BeanPostProcessor`，查看[1.8.1. Customizing Beans by Using a BeanPostProcessor](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-bpp)获取更多信息。


```
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessBeforeInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}

public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      throws BeansException {

   Object result = existingBean;
   for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      result = beanProcessor.postProcessAfterInitialization(result, beanName);
      if (result == null) {
         return result;
      }
   }
   return result;
}
```

#### 7.4.3. 激活自定义的init-method方法

用户定制的初始化方法除了我们熟知的`init-method`方法外，还有使自定义的bean实现`InitializingBean`接口，并在`afterPropertiesSet`中实现自己的初始化业务逻辑。

`init-method`和`afterPropertiesSet`都是在初始化bean时执行，执行顺序是`afterPropertiesSet`先执行，而`init-method`后执行。关于初始化方法，查看[Initialization Callbacks](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)获取更多信息。

```
protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)
      throws Throwable {

   // 检查是否实现了InitializingBean接口
   boolean isInitializingBean = (bean instanceof InitializingBean);
   // 如果实现了则调用其afterPropertiesSet()方法
   if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
      if (logger.isDebugEnabled()) {
         logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
      }
      if (System.getSecurityManager() != null) {
         try {
            AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
               @Override
               public Object run() throws Exception {
                  ((InitializingBean) bean).afterPropertiesSet();
                  return null;
               }
            }, getAccessControlContext());
         }
         catch (PrivilegedActionException pae) {
            throw pae.getException();
         }
      }
      else {
         ((InitializingBean) bean).afterPropertiesSet();
      }
   }

   // 如果指定了init-method，调用此方法
   // 注意，如果init-method方法的名字为afterPropertiesSet，同时这个bean实现了InitializingBean接口，
   // 那么只调用一次，即不会再init-method
   if (mbd != null) {
      String initMethodName = mbd.getInitMethodName();
      if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
            !mbd.isExternallyManagedInitMethod(initMethodName)) {
         invokeCustomInitMethod(beanName, bean, mbd);
      }
   }
}

// 通过反射调用init-method
protected void invokeCustomInitMethod(String beanName, final Object bean, RootBeanDefinition mbd)
      throws Throwable {

   String initMethodName = mbd.getInitMethodName();
   final Method initMethod = (mbd.isNonPublicAccessAllowed() ?
         BeanUtils.findMethod(bean.getClass(), initMethodName) :
         ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));
   // 如果没有符合指定init-method名字的方法，抛出异常
   // isEnforceInitMethod()默认返回true
   if (initMethod == null) {
      if (mbd.isEnforceInitMethod()) {
         throw new BeanDefinitionValidationException("Couldn't find an init method named '" +
               initMethodName + "' on bean with name '" + beanName + "'");
      }
      else {
         if (logger.isDebugEnabled()) {
            logger.debug("No default init method named '" + initMethodName +
                  "' found on bean with name '" + beanName + "'");
         }
         // Ignore non-existent default lifecycle methods.
         return;
      }
   }

   if (logger.isDebugEnabled()) {
      logger.debug("Invoking init method  '" + initMethodName + "' on bean with name '" + beanName + "'");
   }

   // 通过反射调用
   if (System.getSecurityManager() != null) {
      AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
         @Override
         public Object run() throws Exception {
            ReflectionUtils.makeAccessible(initMethod);
            return null;
         }
      });
      try {
         AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
            @Override
            public Object run() throws Exception {
               initMethod.invoke(bean);
               return null;
            }
         }, getAccessControlContext());
      }
      catch (PrivilegedActionException pae) {
         InvocationTargetException ex = (InvocationTargetException) pae.getException();
         throw ex.getTargetException();
      }
   }
   else {
      try {
         ReflectionUtils.makeAccessible(initMethod);
         initMethod.invoke(bean);
      }
      catch (InvocationTargetException ex) {
         throw ex.getTargetException();
      }
   }
}
```

### 7.5. 注册DisposableBean

Spring不但提供了对于初始化方法的接口，同样也提供了销毁方法的拓展入口，对于销毁方法的拓展。除了我们熟知的配置属性`destroy-method`外，用户还可以注册后处理器`DestructionAwareBeanPostProcessor`来统一处理bean的销毁方法。

```
protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
   AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
   // 销毁回调方法不会应用到prototype中
   if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
      if (mbd.isSingleton()) {
         // Register a DisposableBean implementation that performs all destruction
         // work for the given bean: DestructionAwareBeanPostProcessors,
         // DisposableBean interface, custom destroy method.
         registerDisposableBean(beanName,
               new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
      }
      else {
         // A bean with a custom scope...
         Scope scope = this.scopes.get(mbd.getScope());
         if (scope == null) {
            throw new IllegalStateException("No Scope registered for scope name '" + mbd.getScope() + "'");
         }
         scope.registerDestructionCallback(beanName,
               new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
      }
   }
}
```
